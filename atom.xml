<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我爱盐酥鸡</title>
  
  <subtitle>在现实断裂的地方 梦汇成了海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jwchan1996.github.io/"/>
  <updated>2020-04-28T09:14:55.358Z</updated>
  <id>https://jwchan1996.github.io/</id>
  
  <author>
    <name>Jwchan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 容器访问宿主机 mysql</title>
    <link href="https://jwchan1996.github.io/2020/04/28/docker%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BAmysql/"/>
    <id>https://jwchan1996.github.io/2020/04/28/docker容器访问宿主机mysql/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2020-04-28T09:14:55.358Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;# 场景描述&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景描述&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;centos7&lt;/code&gt; 运行 &lt;code&gt;docker&lt;/code&gt; 容器应用时，需要连接宿主机的 &lt;code&gt;mysql&lt;/code&gt; 的 &lt;code&gt;3306&lt;/code&gt; 端口，发现连接不上，&lt;code&gt;docker&lt;/code&gt; 容器无法访问宿主机的 &lt;code&gt;mysql&lt;/code&gt; 数据库。但是，在容器内访问外部网络是可以 &lt;code&gt;ping&lt;/code&gt; 通的。  &lt;/p&gt;
&lt;h3 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;# 原因分析&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;原因分析&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;centos7&lt;/code&gt; 上部署 &lt;code&gt;docker&lt;/code&gt; 容器，其网络模式采用的是 &lt;code&gt;bridger&lt;/code&gt; 模式。&lt;br&gt;启动 &lt;code&gt;docker&lt;/code&gt; 时，&lt;code&gt;docker&lt;/code&gt; 进程会创建一个名为 &lt;code&gt;docker0&lt;/code&gt; 的虚拟网桥，用于宿主机与容器之间的通信。当启动一个 &lt;code&gt;docker&lt;/code&gt; 容器时，&lt;code&gt;docker&lt;/code&gt; 容器将会附加到虚拟网桥上，容器内的报文通过 &lt;code&gt;docker0&lt;/code&gt; 向外转发。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;docker&lt;/code&gt; 容器访问宿主机，那么 &lt;code&gt;docker0&lt;/code&gt; 网桥将报文直接转发到本机，报文的源地址是 &lt;code&gt;docker0&lt;/code&gt; 网段的地址。而如果 &lt;code&gt;docker&lt;/code&gt; 容器访问宿主机以外的机器，&lt;code&gt;docker&lt;/code&gt; 的 &lt;code&gt;SNAT&lt;/code&gt; 网桥会将报文的源地址转换为宿主机的地址，通过宿主机的网卡向外发送。&lt;/p&gt;
&lt;p&gt;因此，当 &lt;code&gt;docker&lt;/code&gt; 容器访问宿主机时，如果宿主机服务端口会被防火墙拦截，那么就无法连通宿主机，出现 &lt;code&gt;No route to host&lt;/code&gt; 的错误。&lt;/p&gt;
&lt;p&gt;而访问宿主机所在局域网内的其他机器，由于报文的源地址是宿主机 &lt;code&gt;ip&lt;/code&gt;，因此，不会被目的机器防火墙拦截，所以可以访问。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jwchan1996.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jwchan1996.github.io/tags/docker/"/>
    
      <category term="mysql" scheme="https://jwchan1996.github.io/tags/mysql/"/>
    
      <category term="centos" scheme="https://jwchan1996.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>JS 模拟实现 call、apply、bind</title>
    <link href="https://jwchan1996.github.io/2019/11/09/js_simulate_call_apply_bind/"/>
    <id>https://jwchan1996.github.io/2019/11/09/js_simulate_call_apply_bind/</id>
    <published>2019-11-08T16:00:00.000Z</published>
    <updated>2019-11-09T03:42:05.771Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实现call&quot;&gt;&lt;a href=&quot;#实现call&quot; class=&quot;headerlink&quot; title=&quot;实现call&quot;&gt;&lt;/a&gt;实现call&lt;/h3&gt;&lt;p&gt;&lt;code&gt;call&lt;/code&gt; 的参数是直接放进去的，第二第三第 &lt;code&gt;n&lt;/code&gt; 个参数全部都是用逗号分割  &lt;/p&gt;
&lt;p&gt;下面是 &lt;code&gt;call&lt;/code&gt; 的用法形式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg1, arg2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arg1, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.a, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;run.call(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a: &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b: &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt; 的作用是可以改变函数的上下文对象，也就是函数里 &lt;code&gt;this&lt;/code&gt; 的指向&lt;br&gt;👉 这是我们模拟实现 &lt;code&gt;call&lt;/code&gt; 的关键  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一个函数作为一个对象的属性，那么通过调用这个对象的属性调用该函数，&lt;code&gt;this&lt;/code&gt; 就是该对象&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://jwchan1996.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="https://jwchan1996.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 call()、apply()、bind() 的用法</title>
    <link href="https://jwchan1996.github.io/2019/10/21/js_call_apply_bind/"/>
    <id>https://jwchan1996.github.io/2019/10/21/js_call_apply_bind/</id>
    <published>2019-10-20T16:00:00.000Z</published>
    <updated>2019-11-09T03:42:36.669Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;# 笔记&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;笔记&lt;/h3&gt;&lt;p&gt;其实是一个很简单的东西，认真看十分钟就能完全理解！&lt;br&gt;先看明白下面：  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例1&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/images/js_call_apply_bind/01.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;obj.objAge;    &lt;span class=&quot;comment&quot;&gt;//17&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.myFun();    &lt;span class=&quot;comment&quot;&gt;//小张年龄undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例2&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/images/js_call_apply_bind/02.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;shows();    &lt;span class=&quot;comment&quot;&gt;//盲僧&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;比较一下这两者 &lt;code&gt;this&lt;/code&gt; 的差别，第一个打印里面的 &lt;code&gt;this&lt;/code&gt; 指向 &lt;code&gt;obj&lt;/code&gt;，第二个全局声明的 &lt;code&gt;shows()&lt;/code&gt; 函数 &lt;code&gt;this&lt;/code&gt; 是 &lt;code&gt;window&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://jwchan1996.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="https://jwchan1996.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>koa-jwt 实现自定义排除动态路由的鉴权</title>
    <link href="https://jwchan1996.github.io/2019/10/18/koa_jwt_unless/"/>
    <id>https://jwchan1996.github.io/2019/10/18/koa_jwt_unless/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2020-04-28T09:30:57.222Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;# 场景描述&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景描述&lt;/h3&gt;&lt;p&gt;🍭 最近在编写 &lt;a href=&quot;https://github.com/ppap6/PPAP.server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;PPAP.server&lt;/code&gt;&lt;/a&gt; 项目，一个基于 &lt;code&gt;koa2&lt;/code&gt; 的 &lt;code&gt;nodejs&lt;/code&gt; 服务端接口程序。&lt;br&gt;由于接口采用的是 &lt;code&gt;RESTful API&lt;/code&gt;，所以鉴权令牌由客户端携带发送到接口。&lt;br&gt;业务需求的是部分接口是需要用户登陆再进行操作，比如需要记录用户点赞的接口。&lt;br&gt;而不需要用户鉴权的接口，如查看帖子等不记录用户数据的接口。  &lt;/p&gt;
&lt;p&gt;对于路由权限控制（鉴权），项目使用的是 &lt;a href=&quot;https://github.com/auth0/node-jsonwebtoken&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;koa-jwt&lt;/code&gt;&lt;/a&gt;，支持对 &lt;code&gt;token&lt;/code&gt; 的生成与校验，还能对接口路由进行过滤排除，指定不需要鉴权的接口。  &lt;/p&gt;
&lt;p&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//配置不需要jwt验证的接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.use(jwtKoa(&amp;#123; &lt;span class=&quot;attr&quot;&gt;secret&lt;/span&gt;: tokenUtil.secret &amp;#125;).unless(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  path: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;/user/login&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;/user/register&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样上面两个接口 &lt;code&gt;/user/login&lt;/code&gt; 和 &lt;code&gt;/user/register&lt;/code&gt; 都是可以跳过鉴权的，不需要携带 &lt;code&gt;token&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于本项目来说，棘手的是项目接口大多使用了动态路由，即比如 &lt;code&gt;/user/:id&lt;/code&gt; 这样的接口，需要用正则表达式去进行匹配。&lt;br&gt;但是动态路由 &lt;code&gt;/user/:id&lt;/code&gt; 的请求方法可能会有 &lt;code&gt;get post put delete&lt;/code&gt; 四种，所以不仅仅要排除配置的静态路由，还需要排除配置的特定请求方法的动态路由。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="https://jwchan1996.github.io/categories/node/"/>
    
    
      <category term="jwt鉴权" scheme="https://jwchan1996.github.io/tags/jwt%E9%89%B4%E6%9D%83/"/>
    
      <category term="koa" scheme="https://jwchan1996.github.io/tags/koa/"/>
    
      <category term="token" scheme="https://jwchan1996.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>443 端口占用导致其他程序启动失败</title>
    <link href="https://jwchan1996.github.io/2019/09/29/https_443_port_occupy/"/>
    <id>https://jwchan1996.github.io/2019/09/29/https_443_port_occupy/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-11-09T03:44:26.553Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;# 笔记&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;笔记&lt;/h3&gt;&lt;p&gt;🧐 由于需要编写基于 &lt;code&gt;go&lt;/code&gt; 的微信公众号接口，端口限制在 &lt;code&gt;80&lt;/code&gt; 端口和 &lt;code&gt;443&lt;/code&gt; 端口之间，所以就只能起一个监听端口为 &lt;code&gt;443&lt;/code&gt; 的 &lt;code&gt;https&lt;/code&gt; 服务。&lt;br&gt;🧐 但是，&lt;code&gt;beego&lt;/code&gt; 运行 &lt;code&gt;443&lt;/code&gt; 端口的 &lt;code&gt;https&lt;/code&gt; 服务，成功运行了而且并没有报错（这是个奇怪的点），但是当访问接口的时候都是返回 &lt;code&gt;404 not found&lt;/code&gt;。&lt;br&gt;🧐 在排除 https 服务异常的情况下（除了 &lt;code&gt;443&lt;/code&gt; 端口其他端口都是正常工作的），最终定位到问题应该在端口占用上。&lt;br&gt;🧐 于是，查看 &lt;code&gt;443&lt;/code&gt; 端口的占用情况，果然有进程在占用着，是 &lt;code&gt;vmware-hostd.exe&lt;/code&gt; 这个进程，然后将它 &lt;code&gt;kill&lt;/code&gt; 掉，然后发现，还是不行，一样是 &lt;code&gt;404 not found&lt;/code&gt;。&lt;br&gt;🧐 出大问题哈哈哈！一开始没注意到 &lt;code&gt;vmware-hostd.exe&lt;/code&gt; 是自启动的，杀掉了还是会重新启动，还捣鼓了几个小时。&lt;br&gt;🧐 所以，后面只需要将 &lt;code&gt;vmware-hostd.exe&lt;/code&gt; 进程设置为手动开启，然后关掉即可释放 &lt;code&gt;443&lt;/code&gt; 端口。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://jwchan1996.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="go" scheme="https://jwchan1996.github.io/tags/go/"/>
    
      <category term="VMware" scheme="https://jwchan1996.github.io/tags/VMware/"/>
    
      <category term="https" scheme="https://jwchan1996.github.io/tags/https/"/>
    
      <category term="微信公众号" scheme="https://jwchan1996.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Electron 踩坑记录（二）</title>
    <link href="https://jwchan1996.github.io/2019/09/12/electron_note_2/"/>
    <id>https://jwchan1996.github.io/2019/09/12/electron_note_2/</id>
    <published>2019-09-11T16:00:00.000Z</published>
    <updated>2020-04-28T09:38:38.742Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;# 场景描述&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景描述&lt;/h3&gt;&lt;p&gt;– &lt;code&gt;2020-04-28&lt;/code&gt; 更新：由于 &lt;code&gt;flash 30&lt;/code&gt; 版本以后会出现提示“未能正确加载必要组件”（其实是广告程序），导致失效，&lt;code&gt;flash&lt;/code&gt; 版本应该替换为 &lt;code&gt;29&lt;/code&gt; 版本。–  &lt;/p&gt;
&lt;p&gt;上一篇 &lt;code&gt;electron&lt;/code&gt; 踩坑(一) 说到 &lt;code&gt;electron&lt;/code&gt; 加载 &lt;code&gt;flash&lt;/code&gt; 的问题&lt;br&gt;采用的是加载系统安装好的 &lt;code&gt;flash&lt;/code&gt; 插件，需要用户提前安装好 &lt;code&gt;flash&lt;/code&gt; 才能正常工作&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.commandLine.appendSwitch(&lt;span class=&quot;string&quot;&gt;&#39;ppapi-flash-path&#39;&lt;/span&gt;, app.getPath(&lt;span class=&quot;string&quot;&gt;&#39;pepperFlashSystemPlugin&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;app.getPath(&amp;#39;pepperFlashSystemPlugin&amp;#39;)&lt;/code&gt; 会自动找寻系统 &lt;code&gt;flash&lt;/code&gt; 的所在路径&lt;br&gt;但是，如果用户没装 &lt;code&gt;flash&lt;/code&gt; 就打开应用，就会提示报错，带来不好的用户体验&lt;br&gt;所以，我们需要将 &lt;code&gt;flash&lt;/code&gt; 嵌入应用依赖，也就是插件跟着应用打包  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;win&lt;/code&gt; 下面的软件有 &lt;code&gt;32&lt;/code&gt; 位和 &lt;code&gt;64&lt;/code&gt; 位的说法，而且安装位置会有不同。那么 &lt;code&gt;flash&lt;/code&gt; 也不例外&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C:\Windows\System32\Macromed\Flash\pepflashplayer64_32_0_0_238.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C:\Windows\SysWOW64\Macromed\Flash\pepflashplayer32_32_0_0_238.dll&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，上面版本号会变化，但是 &lt;code&gt;dll&lt;/code&gt; 所在路径基本是如上所示&lt;br&gt;找到 &lt;code&gt;flash&lt;/code&gt; 所在路径后，我们就可以提取文件放到我们的应用目录下了&lt;br&gt;编译后就会成为应用安装包的一部分，这样就不需要用户手动安装 &lt;code&gt;flash&lt;/code&gt; 了&lt;br&gt;🔥 那么，在 &lt;code&gt;electron&lt;/code&gt; 目录下应该如何引入呢？&lt;br&gt;
    
    </summary>
    
      <category term="electron" scheme="https://jwchan1996.github.io/categories/electron/"/>
    
    
      <category term="electron" scheme="https://jwchan1996.github.io/tags/electron/"/>
    
      <category term="elecrton-vue" scheme="https://jwchan1996.github.io/tags/elecrton-vue/"/>
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
      <category term="flash" scheme="https://jwchan1996.github.io/tags/flash/"/>
    
  </entry>
  
  <entry>
    <title>koa 实现 token 有效时间续期的思路</title>
    <link href="https://jwchan1996.github.io/2019/09/06/koa_token/"/>
    <id>https://jwchan1996.github.io/2019/09/06/koa_token/</id>
    <published>2019-09-05T16:00:00.000Z</published>
    <updated>2020-04-28T09:30:36.765Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;# 场景描述&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景描述&lt;/h3&gt;&lt;p&gt;🍭 在前后端的交互中，无可避免的存在一些需要验证身份的请求。&lt;br&gt;🍭 一般来说，使用 &lt;code&gt;token&lt;/code&gt; 作为身份令牌可以实现身份验证的问题。&lt;br&gt;🍭 以此同时，&lt;code&gt;token&lt;/code&gt; 作为自带描述信息的无状态数据，唯一的判断标准就是生成 &lt;code&gt;token&lt;/code&gt; 时设置的有效期时间，当超过有效期时则作废。&lt;br&gt;🍭 我们在使用 &lt;code&gt;APP&lt;/code&gt; 或 &lt;code&gt;WEB&lt;/code&gt; 应用时，如果正在操作的时候，&lt;code&gt;token&lt;/code&gt; 刚好过期了，那就出大问题了。&lt;br&gt;🍭 所有的数据请求都会失败，给用户带来极其糟糕的体验。&lt;br&gt;🍭 所以，如何才能让 &lt;code&gt;token&lt;/code&gt; 进行续期呢？  &lt;/p&gt;
&lt;h3 id=&quot;处理思路&quot;&gt;&lt;a href=&quot;#处理思路&quot; class=&quot;headerlink&quot; title=&quot;# 处理思路&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;处理思路&lt;/h3&gt;&lt;p&gt;🍤 因为 &lt;code&gt;token&lt;/code&gt; 是无状态数据，一旦生成了，不能主动删除或者让它失效，唯一的就是等待有效期时间到。&lt;br&gt;🍤 所以，我们会想到，在 &lt;code&gt;token&lt;/code&gt; 过期时客户端携带新的 &lt;code&gt;token&lt;/code&gt; 来访问数据接口，是不是就可以了呢。&lt;br&gt;🍤 答案是的，那么现在需要解决的问题就是：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.怎么返回新的 token 给到客户端&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.什么时候返回 token 使得用户登录状态得到续期&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="https://jwchan1996.github.io/categories/node/"/>
    
    
      <category term="koa" scheme="https://jwchan1996.github.io/tags/koa/"/>
    
      <category term="token" scheme="https://jwchan1996.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>Electron 踩坑记录（一）</title>
    <link href="https://jwchan1996.github.io/2019/08/09/electron_note_1/"/>
    <id>https://jwchan1996.github.io/2019/08/09/electron_note_1/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-11-09T03:45:18.262Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;# 场景描述&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景描述&lt;/h3&gt;&lt;p&gt;构建 &lt;code&gt;pc&lt;/code&gt; 客户端，采用 &lt;code&gt;electron-vue&lt;/code&gt; 脚手架进行快速搭建环境。&lt;br&gt;功能点在 &lt;code&gt;web&lt;/code&gt; 端全部正常，移植代码到 &lt;code&gt;electron&lt;/code&gt; 时出现问题的功能点有：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. rtmp 流媒体的播放  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. ant-design-vue UI 框架部分组件失效&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;🔥 播放器使用的是 &lt;code&gt;vue-video-player&lt;/code&gt;，播放 &lt;code&gt;rtmp&lt;/code&gt; 流需要使用 &lt;code&gt;flash&lt;/code&gt; 技术。  &lt;/p&gt;
&lt;h3 id=&quot;问题解决&quot;&gt;&lt;a href=&quot;#问题解决&quot; class=&quot;headerlink&quot; title=&quot;# 问题解决&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;问题解决&lt;/h3&gt;&lt;p&gt;简单记录问题关键&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;问题：pc 客户端 ant-design-vue 部分组件不能正常工作 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原因：electron-vue 将它视为 webpack 的 externals 了，其中 UI 组件含有的 vue 文件没有被 vue-loader 正常编译，才导致功能失效&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解决：找到 .electron-vue/webpack.renderer.config.js 将 ant-design-vue 加入到白名单 whiteListedModules&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;🧐 &lt;a href=&quot;https://simulatedgreg.gitbooks.io/electron-vue/content/en/webpack-configurations.html#white-listing-externals&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron 白名单配置&lt;/a&gt;
    
    </summary>
    
      <category term="electron" scheme="https://jwchan1996.github.io/categories/electron/"/>
    
    
      <category term="electron" scheme="https://jwchan1996.github.io/tags/electron/"/>
    
      <category term="elecrton-vue" scheme="https://jwchan1996.github.io/tags/elecrton-vue/"/>
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
      <category term="flash" scheme="https://jwchan1996.github.io/tags/flash/"/>
    
      <category term="vue-video-player" scheme="https://jwchan1996.github.io/tags/vue-video-player/"/>
    
      <category term="rtmp" scheme="https://jwchan1996.github.io/tags/rtmp/"/>
    
      <category term="ant-design-vue" scheme="https://jwchan1996.github.io/tags/ant-design-vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 重新加载当前组件</title>
    <link href="https://jwchan1996.github.io/2019/07/25/vue_reload_component/"/>
    <id>https://jwchan1996.github.io/2019/07/25/vue_reload_component/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-11-09T03:45:29.990Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vue-重新加载当前组件&quot;&gt;&lt;a href=&quot;#vue-重新加载当前组件&quot; class=&quot;headerlink&quot; title=&quot;# vue 重新加载当前组件&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;vue 重新加载当前组件&lt;/h3&gt;&lt;p&gt;🍍 遇到问题的场景&lt;br&gt;需要把当前组件完全还原成初始化状态，不要页面全部刷新&lt;br&gt;🍍 例如：播放 &lt;code&gt;rtmp&lt;/code&gt; 直播视频流的时候，点击暂停之后，想要恢复播放，需要重新载入当前播放器才行。&lt;br&gt;🍍 情景：使用了 &lt;code&gt;vue-video-player&lt;/code&gt; 播放器，点击视频播放界面，会暂停，因为播放的是 &lt;code&gt;rtmp&lt;/code&gt; 直播流，想要恢复的话必须重新加载视频流以及加载 &lt;code&gt;flash&lt;/code&gt; 等插件才行，此时简单的替换播放源 &lt;code&gt;src&lt;/code&gt; 是不可行的，需要的是重新初始化当前播放器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vue_reload_component/01.png&quot; alt=&quot;暂停&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://jwchan1996.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>map 字符串数组/数字数组 快速转换</title>
    <link href="https://jwchan1996.github.io/2019/06/27/js_map/"/>
    <id>https://jwchan1996.github.io/2019/06/27/js_map/</id>
    <published>2019-06-26T16:00:00.000Z</published>
    <updated>2019-11-09T03:46:12.025Z</updated>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="笔记" scheme="https://jwchan1996.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="https://jwchan1996.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>响应路由参数的变化保持功能选中状态</title>
    <link href="https://jwchan1996.github.io/2019/05/28/vue_watch_$route/"/>
    <id>https://jwchan1996.github.io/2019/05/28/vue_watch_$route/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-11-09T03:46:28.756Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;# 背景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;背景&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;vue + vue-router&lt;/code&gt; 的项目中，单页面路由的出现使得页面加载更加优雅。&lt;br&gt;但与此同时，也会出现一些问题。&lt;/p&gt;
&lt;p&gt;比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 页面刷新如何保持功能选中状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 浏览器前进后退如何保持功能选中状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;😑 关于这两个问题，我们很容易想到通过监听路由地址来解决。&lt;/p&gt;
&lt;h4 id=&quot;页面刷新&quot;&gt;&lt;a href=&quot;#页面刷新&quot; class=&quot;headerlink&quot; title=&quot;# 页面刷新&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;页面刷新&lt;/h4&gt;&lt;p&gt;对于问题 &lt;code&gt;1&lt;/code&gt; ，解决方法就是在页面加载时根据路由地址判断当前选择的是什么，从而激活对应的选中样式。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://jwchan1996.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
      <category term="vue-router" scheme="https://jwchan1996.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>关于 ref 与 $refs 对 dom 元素的操作</title>
    <link href="https://jwchan1996.github.io/2019/05/14/vue_$refs/"/>
    <id>https://jwchan1996.github.io/2019/05/14/vue_$refs/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-11-09T03:46:42.122Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何获取-v-for-渲染的多个不同-ref-的-dom&quot;&gt;&lt;a href=&quot;#如何获取-v-for-渲染的多个不同-ref-的-dom&quot; class=&quot;headerlink&quot; title=&quot;# 如何获取 v-for 渲染的多个不同 ref 的 dom&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;如何获取 v-for 渲染的多个不同 ref 的 dom&lt;/h3&gt;&lt;p&gt;🍍 在编写 &lt;code&gt;vue&lt;/code&gt; 项目过程中，遇到了获取不到正确的 &lt;code&gt;dom&lt;/code&gt; 元素节点的问题。&lt;/p&gt;
&lt;p&gt;功能界面如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vue_$refs/vue_$refs_01.png&quot; alt=&quot;界面&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要实现的是，点击每个播放器的右上角的关闭按钮，则关闭播放器。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://jwchan1996.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于 axios 请求出现 OPTIONS</title>
    <link href="https://jwchan1996.github.io/2019/05/06/axios_options/"/>
    <id>https://jwchan1996.github.io/2019/05/06/axios_options/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-11-09T03:46:53.604Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么-axios-先要请求-OPTIONS-再请求-POST&quot;&gt;&lt;a href=&quot;#为什么-axios-先要请求-OPTIONS-再请求-POST&quot; class=&quot;headerlink&quot; title=&quot;# 为什么 axios 先要请求 OPTIONS 再请求 POST&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;为什么 axios 先要请求 OPTIONS 再请求 POST&lt;/h3&gt;&lt;p&gt;🎨 最近在用 &lt;code&gt;vue&lt;/code&gt; 重写一个以前的 &lt;code&gt;angular&lt;/code&gt; + &lt;code&gt;thinkjs&lt;/code&gt; 的项目，由于项目环境的前后端分离了，就出现了跨域问题，配置了一下 &lt;code&gt;CORS&lt;/code&gt; 解决了跨域问题之后，又出现了 &lt;code&gt;axios&lt;/code&gt; 请求发送两次的情况。&lt;/p&gt;
&lt;p&gt;以登录功能为例，一共发送两个请求，第一个是 &lt;code&gt;OPTIONS&lt;/code&gt; 请求，第二个是 &lt;code&gt;POST&lt;/code&gt; 请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;axios&lt;/code&gt; 配置如下：
    
    </summary>
    
      <category term="axios" scheme="https://jwchan1996.github.io/categories/axios/"/>
    
    
      <category term="axios" scheme="https://jwchan1996.github.io/tags/axios/"/>
    
      <category term="跨域" scheme="https://jwchan1996.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="options" scheme="https://jwchan1996.github.io/tags/options/"/>
    
  </entry>
  
  <entry>
    <title>软件版本命名规则</title>
    <link href="https://jwchan1996.github.io/2019/04/17/version_number/"/>
    <id>https://jwchan1996.github.io/2019/04/17/version_number/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-11-09T03:47:03.819Z</updated>
    
    <summary type="html">
    
      &lt;style&gt;
    #version_number_01{
        border: 0 !important;
        /**设置缩放**/
        -webkit-transition: 0.2s all;
        -moz-transition: 0.2s all;
        -ms-transition: 0.2s all;
        transition: 0.2s all;
    }
    #version_number_01:hover{
        -webkit-transform: scale(1.02,1.02);
        -moz-transform: scale(1.02,1.02);
        -ms-transform: scale(1.02,1.02);
        transform: scale(1.02,1.02);
        box-shadow: 5px 5px 30px #999;
        cursor: pointer;
    }
&lt;/style&gt;

&lt;h3 id=&quot;版本号命名规则&quot;&gt;&lt;a href=&quot;#版本号命名规则&quot; class=&quot;headerlink&quot; title=&quot;# 版本号命名规则&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;版本号命名规则&lt;/h3&gt;&lt;p&gt;🍰 软件版本号有四部分组成：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第一部分为主版本号  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二部分为次版本号  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三部分为修订版本号  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第四部分为日期版本号加希腊字母版本号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img id=&quot;version_number_01&quot; src=&quot;/images/version_number.png&quot;&gt;
    
    </summary>
    
      <category term="知识" scheme="https://jwchan1996.github.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="认知" scheme="https://jwchan1996.github.io/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>获取 v-html 渲染的富文本数据元素内容</title>
    <link href="https://jwchan1996.github.io/2019/03/20/vue_v-html/"/>
    <id>https://jwchan1996.github.io/2019/03/20/vue_v-html/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2019-11-09T03:47:15.739Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;# 场景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景&lt;/h3&gt;&lt;p&gt;🍰 在业务中，往往有时候需要处理富文本格式的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;富文本格式数据： 带有html标签的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在传统的 &lt;code&gt;web&lt;/code&gt; 开发下，当我们获取到数据，只要使用 &lt;code&gt;append&lt;/code&gt; 或 &lt;code&gt;innerHtml&lt;/code&gt; 将元素添加到 &lt;code&gt;dom&lt;/code&gt; 中，再使用 &lt;code&gt;document.querySelector()&lt;/code&gt; 即可获取 &lt;code&gt;dom&lt;/code&gt; 元素。  &lt;/p&gt;
&lt;p&gt;而在 &lt;code&gt;vue&lt;/code&gt; 中，页面渲染完毕，&lt;code&gt;v-html&lt;/code&gt; 并没有触发页面渲染的重新执行，所以使用 &lt;code&gt;document.querySelector()&lt;/code&gt; 方式是获取不到数据的，因为 &lt;code&gt;dom&lt;/code&gt; 早在第一次加载时候就渲染完毕了，也就自然获取不到。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://jwchan1996.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于控制台打印点击事件目标元素的 currentTarget 为 null</title>
    <link href="https://jwchan1996.github.io/2019/02/20/currentTarget_console_log/"/>
    <id>https://jwchan1996.github.io/2019/02/20/currentTarget_console_log/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-11-09T03:47:28.491Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;# 场景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景&lt;/h3&gt;&lt;p&gt;JS 代码：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; target = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;target&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(e.currentTarget);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jwchan1996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jwchan1996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实现平滑滚动回到顶部</title>
    <link href="https://jwchan1996.github.io/2019/01/27/back_to_top/"/>
    <id>https://jwchan1996.github.io/2019/01/27/back_to_top/</id>
    <published>2019-01-26T16:00:00.000Z</published>
    <updated>2019-11-09T03:47:46.065Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;# 场景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;场景&lt;/h3&gt;&lt;p&gt;🍰 实现页面滚动到一定位置，出现返回顶部图标&lt;br&gt;🍰 点击图标实现页面平滑滚动返回顶部&lt;/p&gt;
&lt;h3 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;# 方案&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688&quot;&gt;# &lt;/span&gt;方案&lt;/h3&gt;&lt;p&gt;采用 window.requestAnimationFrame( ) 实现
    
    </summary>
    
      <category term="前端" scheme="https://jwchan1996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jwchan1996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>使用 git 向开源项目提交 pull request</title>
    <link href="https://jwchan1996.github.io/2019/01/20/git_pull_request/"/>
    <id>https://jwchan1996.github.io/2019/01/20/git_pull_request/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-11-09T03:48:00.264Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Pull-Request-是什么&quot;&gt;&lt;a href=&quot;#Pull-Request-是什么&quot; class=&quot;headerlink&quot; title=&quot;#Pull Request 是什么&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688;&quot;&gt;#&lt;/span&gt;Pull Request 是什么&lt;/h3&gt;&lt;p&gt;⛏️ &lt;code&gt;Pull Request&lt;/code&gt; 是一种通知机制&lt;br&gt;你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 &lt;code&gt;Pull Request&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;⛏️ &lt;code&gt;Pull Request&lt;/code&gt; 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码  &lt;/p&gt;
&lt;p&gt;⛏️ 简单的说是在自己本地仓库修改代码，提交到自己远程仓库，提交 &lt;code&gt;PR&lt;/code&gt; 后被接受后，再会被合并到 &lt;code&gt;master&lt;/code&gt;
    
    </summary>
    
      <category term="git" scheme="https://jwchan1996.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://jwchan1996.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>解决 apicloud 下关闭 Win 页面失效问题</title>
    <link href="https://jwchan1996.github.io/2019/01/16/apicloud_closeWin/"/>
    <id>https://jwchan1996.github.io/2019/01/16/apicloud_closeWin/</id>
    <published>2019-01-15T16:00:00.000Z</published>
    <updated>2019-11-09T03:48:13.688Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;#场景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688;&quot;&gt;#&lt;/span&gt;场景&lt;/h3&gt;&lt;p&gt;🌈 在使用 &lt;code&gt;apicloud&lt;/code&gt; 开发相关应用的时候，经常会遇到打开一个新的 &lt;code&gt;Window&lt;/code&gt; 页面，&lt;br&gt;同时需要把其他 &lt;code&gt;Window&lt;/code&gt; 或 &lt;code&gt;Frame&lt;/code&gt; 页面关闭的情况。&lt;br&gt;以下是官网 &lt;code&gt;api&lt;/code&gt; 文档的描述：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;closeWin&lt;/code&gt; 方法可以关闭 &lt;code&gt;Window&lt;/code&gt;，但注意，若当前正在进行 &lt;code&gt;openWin&lt;/code&gt;、&lt;code&gt;closeWin&lt;/code&gt; 等带动画过渡的 &lt;code&gt;Window&lt;/code&gt; 操作，调用此方法会失效。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="混合APP" scheme="https://jwchan1996.github.io/categories/%E6%B7%B7%E5%90%88APP/"/>
    
    
      <category term="apicloud" scheme="https://jwchan1996.github.io/tags/apicloud/"/>
    
  </entry>
  
  <entry>
    <title>非模块化下实现简单 vue-router 应用</title>
    <link href="https://jwchan1996.github.io/2019/01/10/vue_router_nomodular/"/>
    <id>https://jwchan1996.github.io/2019/01/10/vue_router_nomodular/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-11-09T03:48:23.568Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;#场景&quot;&gt;&lt;/a&gt;&lt;span style=&quot;color:#009688;&quot;&gt;#&lt;/span&gt;场景&lt;/h3&gt;&lt;p&gt;一般情况下，我们使用工程化构建应用，需要的是导入 &lt;code&gt;Vue&lt;/code&gt; 和 &lt;code&gt;VueRouter&lt;/code&gt;，然后要调用 &lt;code&gt;Vue.use(VueRouter)&lt;/code&gt;&lt;br&gt;那么，如果是非模块化 &lt;code&gt;vue&lt;/code&gt; 使用 &lt;code&gt;vue-router&lt;/code&gt; 应用的实现，是怎么样的呢？  &lt;/p&gt;
&lt;p&gt;🍭 下面是贴代码时间：
    
    </summary>
    
      <category term="vue" scheme="https://jwchan1996.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://jwchan1996.github.io/tags/vue/"/>
    
      <category term="vue-router" scheme="https://jwchan1996.github.io/tags/vue-router/"/>
    
  </entry>
  
</feed>
