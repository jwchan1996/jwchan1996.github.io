<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker 容器访问宿主机 mysql]]></title>
    <url>%2F2020%2F04%2F28%2Fdocker%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BAmysql%2F</url>
    <content type="text"><![CDATA[# 场景描述在 centos7 运行 docker 容器应用时，需要连接宿主机的 mysql 的 3306 端口，发现连接不上，docker 容器无法访问宿主机的 mysql 数据库。但是，在容器内访问外部网络是可以 ping 通的。 # 原因分析在 centos7 上部署 docker 容器，其网络模式采用的是 bridger 模式。启动 docker 时，docker 进程会创建一个名为 docker0 的虚拟网桥，用于宿主机与容器之间的通信。当启动一个 docker 容器时，docker 容器将会附加到虚拟网桥上，容器内的报文通过 docker0 向外转发。 如果 docker 容器访问宿主机，那么 docker0 网桥将报文直接转发到本机，报文的源地址是 docker0 网段的地址。而如果 docker 容器访问宿主机以外的机器，docker 的 SNAT 网桥会将报文的源地址转换为宿主机的地址，通过宿主机的网卡向外发送。 因此，当 docker 容器访问宿主机时，如果宿主机服务端口会被防火墙拦截，那么就无法连通宿主机，出现 No route to host 的错误。 而访问宿主机所在局域网内的其他机器，由于报文的源地址是宿主机 ip，因此，不会被目的机器防火墙拦截，所以可以访问。 # 解决问题首先设置了 mysql 的配置文件，保证 mysql 可以被任何 ip 访问：12[mysqld]bind-address = 0.0.0.0 修改完配置文件重启生效。但为了安全考虑，防火墙的 3306 端口仍然是不开放外网访问的。 # 方式一容器访问宿主机的地址需要使用 docker0 的地址。编辑防火墙文件 /etc/firewalld/zones/public.xml，添加下面配置：1234&lt;rule family="ipv4"&gt; &lt;source address="172.18.0.0/16"/&gt; &lt;accept/&gt;&lt;/rule&gt; 重启防火墙，docker 容器即可正常访问宿主机端口。1service firewalld restart # 方式二容器访问宿主机通过走内网的方式，可绕过防火墙限制。需要使用的地址是宿主机 eth0 的地址。运行 ifconfig 即可查看得到。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 模拟实现 call、apply、bind]]></title>
    <url>%2F2019%2F11%2F09%2Fjs_simulate_call_apply_bind%2F</url>
    <content type="text"><![CDATA[实现callcall 的参数是直接放进去的，第二第三第 n 个参数全部都是用逗号分割 下面是 call 的用法形式： 12345678910111213function test(arg1, arg2) &#123; console.log(arg1, arg2) console.log(this.a, this.b)&#125;run.call( &#123; a: "a", b: "b" &#125;, 1, 2) call 的作用是可以改变函数的上下文对象，也就是函数里 this 的指向👉 这是我们模拟实现 call 的关键 如果一个函数作为一个对象的属性，那么通过调用这个对象的属性调用该函数，this 就是该对象1234567891011let obj = &#123; a: "a", b: "b", test: function(arg1, arg2) &#123; console.log(arg1, arg2) // this.a 就是 a; this.b 就是 b console.log(this.a, this.b) &#125;&#125;obj.test(1, 2) 下面就是模拟实现 call：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Function.prototype.call2 = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; //默认执行上下文是window context = context || window //this指向调用call2的函数（调用函数） //将"调用函数"赋值给执行上下文对象的一个属性 //成为上下文对象的方法 //context.fn = this //考虑到属性名可能重复的情况，需要一个唯一的属性名（使用Symbol） const fn = Symbol('fn') context[fn] = this //对call2传入的参数进行提取 //[...arguments].slice(0,1)是上下文对象 //[...arguments].slice(1)是参数数组 const args = [...arguments].slice(1) //调用上下文对象的方法 //此时方法内部的this指向的是上下文对象 //实现重定义"调用函数"的this指向 const result = context[fn](...args) //删除临时定义的属性 delete context[fn] return result &#125;// 以下是测试代码function test(arg1, arg2) &#123; console.log(arg1, arg2) //1,2 console.log(this.a, this.b) //a,b&#125;test.call2( &#123; a: "a", b: "b" &#125;, 1, 2) 实现applyapply 的参数都必须放在一个数组里面传进去，即第二个参数是数组1234567891011121314151617181920212223242526272829303132333435363738Function.prototype.apply2 = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; context = context || window //context.fn = this //考虑到属性名可能重复的情况，需要一个唯一的属性名（使用Symbol） const fn = Symbol('fn') context[fn] = this let result //apply要求传入的第二个参数是数组 if(Array.isArray(arguments[1]))&#123; result = context[fn](...arguments[1]) &#125;else&#123; result = context[fn]() &#125; delete context[fn] return result&#125;// 以下是测试代码function test(arg1, arg2) &#123; console.log(arg1, arg2) //1,2 console.log(this.a, this.b) //a,b&#125;test.apply2( &#123; a: "a", b: "b" &#125;, [1, 2]) 实现bindbind 返回的是一个函数，参数传递跟 call 一样，返回的函数被调用是也可以带参数，bind 内部会将参数进行合并 因为 bind 返回的是一个函数，所以需要考虑函数作为构造函数进行 new 创建对象的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546Function.prototype.bind2 = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; context = context || window //this指向调用bind2的函数 const that = this //此处的arguments指传入bind2的参数 const args = [...arguments].slice(1) return function F()&#123; //若返回的F函数被当作构造函数new创建实例 //则此时this指向构造函数实例，不会改变上下文 //若返回的F函数当作普通函数全局调用时 //则this指向window if(this instanceof F)&#123; //此处的arguments指传入F的参数 return new that(...args, ...arguments) &#125; //return that.call(context, ...args.concat(...arguments)) return that.apply(context, args.concat(...arguments)) &#125; &#125;// 以下是测试代码function test(arg1, arg2) &#123; console.log(arg1, arg2) //1,2 console.log(this.a, this.b) //a,b&#125;const test2 = test.call2( &#123; a: "a", b: "b" &#125;, 1 //参数一)test2(2) //参数二 🎨 关于 call、apply、bind 的用法可以查看上一篇文章]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 call()、apply()、bind() 的用法]]></title>
    <url>%2F2019%2F10%2F21%2Fjs_call_apply_bind%2F</url>
    <content type="text"><![CDATA[# 笔记其实是一个很简单的东西，认真看十分钟就能完全理解！先看明白下面： 例112obj.objAge; //17obj.myFun(); //小张年龄undefined 例21shows(); //盲僧 比较一下这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window。 call()、apply()、bind() 都是用来重定义 this 这个对象的！ 如：123obj.myFun.call(db); //德玛年龄99obj.myFun.apply(db); //德玛年龄99obj.myFun.bind(db)(); //德玛年龄99 以上除了 bind 方法后面多了个 () 外，结果返回都一致！由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。 对比call 、bind 、 apply 传参情况下 1234obj.myFun.call(db,'成都','上海'); //德玛 年龄 99 来自 成都去往上海obj.myFun.apply(db,['成都','上海']); //德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,'成都','上海')(); //德玛 年龄 99 来自 成都去往上海 obj.myFun.bind(db,['成都','上海'])(); //德玛 年龄 99 来自 成都,上海去往undefined 从上面四个结果不难看出 call、bind、apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了： call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,&#39;成都&#39;, ... ,&#39;string&#39;) apply 的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,[&#39;成都&#39;, ..., &#39;string&#39;]) bind 除了返回是函数以外，它的参数和 call 一样 当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数、object 等等！ 原文地址：https://www.cnblogs.com/Shd-Study/p/6560808.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa-jwt 实现自定义排除动态路由的鉴权]]></title>
    <url>%2F2019%2F10%2F18%2Fkoa_jwt_unless%2F</url>
    <content type="text"><![CDATA[# 场景描述🍭 最近在编写 PPAP.server 项目，一个基于 koa2 的 nodejs 服务端接口程序。由于接口采用的是 RESTful API，所以鉴权令牌由客户端携带发送到接口。业务需求的是部分接口是需要用户登陆再进行操作，比如需要记录用户点赞的接口。而不需要用户鉴权的接口，如查看帖子等不记录用户数据的接口。 对于路由权限控制（鉴权），项目使用的是 koa-jwt，支持对 token 的生成与校验，还能对接口路由进行过滤排除，指定不需要鉴权的接口。 如：1234567//配置不需要jwt验证的接口app.use(jwtKoa(&#123; secret: tokenUtil.secret &#125;).unless(&#123; path: [ '/user/login', '/user/register' ]&#125;)); 这样上面两个接口 /user/login 和 /user/register 都是可以跳过鉴权的，不需要携带 token。 对于本项目来说，棘手的是项目接口大多使用了动态路由，即比如 /user/:id 这样的接口，需要用正则表达式去进行匹配。但是动态路由 /user/:id 的请求方法可能会有 get post put delete 四种，所以不仅仅要排除配置的静态路由，还需要排除配置的特定请求方法的动态路由。在阅读 koa-jwt 源码后，发现 koa-jwt 的 unless 方法调用了 koa-unless 这个包，于是去阅读了 koa-unless 之后，发现可配置以下参数：12345- method 它可以是一个字符串或字符串数组。如果请求方法匹配，则中间件将不会运行。- path 它可以是字符串，正则表达式或其中任何一个的数组。如果请求路径匹配，则中间件将不会运行。- ext 它可以是一个字符串或字符串数组。如果请求路径以这些扩展名之一结尾，则中间件将不会运行。- custom 它必须是一个返回 true/ 的函数 false。如果函数针对给定的请求返回 true，则中间件将不会运行。该功能将通过 this 访问 Koa 的上下文- useOriginalUrl 应该为 true 或 false，默认为 true。如果为false，path 则匹配 this.url 而不是 this.originalUrl。 结合项目的实际情况，解决方法只能是使用 custom 配置自定义函数进行判断。 # 解决方法🍭 使用 custom 自定义函数进行过滤，创建文件 jwt_unless.js。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 用于判断客户端当前请求接口是否需要jwt验证 *///定义不需要jwt验证的接口数组(get方法)const nonTokenApiArr = [ '/', '/post']//定义不需要jwt验证的接口正则数组(get方法)const nonTokenApiRegArr = [ /^\/user\/\d/, /^\/post\/\d/]//判断请求api是否在数组里const isNonTokenApi = (path) =&gt; &#123; return nonTokenApiArr.includes(path)&#125;//判断请求api是否在正则数组里const isNonTokenRegApi = (path) =&gt; &#123; return nonTokenApiRegArr.some(p =&gt; &#123; return (typeof p === 'string' &amp;&amp; p === path) || (p instanceof RegExp &amp;&amp; !! p.exec(path)) &#125;);&#125;//判断当前请求api是否不需要jwt验证const checkIsNonTokenApi = (ctx) =&gt; &#123; if((isNonTokenApi(ctx.path) || isNonTokenRegApi(ctx.path)) &amp;&amp; ctx.method == 'GET')&#123; return true &#125;else&#123; //特殊post接口，不需要验证jwt if(ctx.path == '/user/login' || ctx.path == 'user/register')&#123; return true &#125; return false &#125;&#125;module.exports = &#123; nonTokenApiArr, nonTokenApiRegArr, isNonTokenApi, isNonTokenRegApi, checkIsNonTokenApi&#125; 然后在 app.js 里引入 jwt_unless.js。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const Koa = require('koa')const bodyParser = require('koa-bodyparser')const jwtKoa = require('koa-jwt') // 用于路由权限控制const app = new Koa()const tokenUtil = require('./util/token')const router = require('./router')const jwtUnless = require('./util/jwt_unless') //用于判断是否需要jwt验证//配置ctx.body解析中间件app.use(bodyParser())// 错误处理app.use((ctx, next) =&gt; &#123; //获取token，保存全局变量 if(ctx.request.header.authorization)&#123; global.token = ctx.request.header.authorization.split(' ')[1] &#125; return next().then(() =&gt; &#123; //判断不需要jwt验证的接口，跳过token续期判断 if(jwtUnless.checkIsNonTokenApi(ctx)) return //判断token是否应该续期（有效时间） if(tokenUtil.getTokenRenewStatus())&#123; //设置header ctx.set(&#123; new_token: tokenUtil.createNewToken() &#125;) &#125; &#125;).catch((err) =&gt; &#123; if(err.status === 401)&#123; ctx.status = 401; ctx.body = &#123; status: 401, message: '未携带token令牌或者token令牌已过期' &#125; &#125;else&#123; throw err; &#125; &#125;)&#125;)//配置不需要jwt验证的接口app.use(jwtKoa(&#123; secret: tokenUtil.secret &#125;).unless(&#123; //自定义过滤函数，详细参考koa-unless custom: ctx =&gt; &#123; if(jwtUnless.checkIsNonTokenApi(ctx))&#123; return true &#125;else&#123; return false &#125; &#125;&#125;));//初始化路由中间件app.use(router.routes()).use(router.allowedMethods())//监听启动窗口app.listen(2333, () =&gt; console.log("PPAP.server is run on localhost:2333")) 到此就实现了对静态及动态路由鉴权，以及对 token 有效时间续期的判断。以上的示例针对的是 get 方法动态路由的判断，如果限制除了 get 请求外的多个请求方法，则需要在定义正则数组的时候，将请求方法跟正则表达式对应起来，如：12345678910111213141516171819202122232425262728const nonTokenApiRegArr = [ &#123; path: /^\/user\/\d/, method: "GET" &#125;, &#123; path: /^\/user\/\d/, method: "POST" &#125;,]………………//判断请求api是否在正则数组里const isNonTokenRegApi = (path, method) =&gt; &#123; return nonTokenApiRegArr.some(p =&gt; &#123; return (typeof p.path === 'string' &amp;&amp; p.path === path &amp;&amp; p.method === method) || (p.path instanceof RegExp &amp;&amp; !! p.path.exec(path) &amp;&amp; p.method === method) &#125;);&#125;//判断当前请求api是否不需要jwt验证const checkIsNonTokenApi = (ctx) =&gt; &#123; if(isNonTokenApi(ctx.path) || isNonTokenRegApi(ctx.path, ctx.method))&#123; return true &#125;else&#123; return false &#125;&#125; 更多详细请访问 https://github.com/ppap6/PPAP.server]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>jwt鉴权</tag>
        <tag>koa</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[443 端口占用导致其他程序启动失败]]></title>
    <url>%2F2019%2F09%2F29%2Fhttps_443_port_occupy%2F</url>
    <content type="text"><![CDATA[# 笔记🧐 由于需要编写基于 go 的微信公众号接口，端口限制在 80 端口和 443 端口之间，所以就只能起一个监听端口为 443 的 https 服务。🧐 但是，beego 运行 443 端口的 https 服务，成功运行了而且并没有报错（这是个奇怪的点），但是当访问接口的时候都是返回 404 not found。🧐 在排除 https 服务异常的情况下（除了 443 端口其他端口都是正常工作的），最终定位到问题应该在端口占用上。🧐 于是，查看 443 端口的占用情况，果然有进程在占用着，是 vmware-hostd.exe 这个进程，然后将它 kill 掉，然后发现，还是不行，一样是 404 not found。🧐 出大问题哈哈哈！一开始没注意到 vmware-hostd.exe 是自启动的，杀掉了还是会重新启动，还捣鼓了几个小时。🧐 所以，后面只需要将 vmware-hostd.exe 进程设置为手动开启，然后关掉即可释放 443 端口。 # 具体因为装了 VMware 虚拟机软件，所以 443 端口被占用了，然后又是默认启动启动的。一般来说，解决方法有两种： 第一种是修改程序的监听端口，设置为空闲的端口即可 第二种就是将占用端口的进程关掉。 因为微信配置接口一定是 80 端口或者 443 端口，所以选择第二种方法。 🔥 在桌面计算机图标点击右键，选择“管理→服务和应用程序→服务”，将显示名称为 VMware Workstation Server 的服务的启动类型改为手动，并停止该服务即可。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>VMware</tag>
        <tag>https</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron 踩坑记录（二）]]></title>
    <url>%2F2019%2F09%2F12%2Felectron_note_2%2F</url>
    <content type="text"><![CDATA[# 场景描述上一篇 electron 踩坑(一) 说到 electron 加载 flash 的问题采用的是加载系统安装好的 flash 插件，需要用户提前安装好 flash 才能正常工作1app.commandLine.appendSwitch('ppapi-flash-path', app.getPath('pepperFlashSystemPlugin')); 其中 app.getPath(&#39;pepperFlashSystemPlugin&#39;) 会自动找寻系统 flash 的所在路径但是，如果用户没装 flash 就打开应用，就会提示报错，带来不好的用户体验所以，我们需要将 flash 嵌入应用依赖，也就是插件跟着应用打包 win 下面的软件有 32 位和 64 位的说法，而且安装位置会有不同。那么 flash 也不例外12C:\Windows\System32\Macromed\Flash\pepflashplayer64_32_0_0_238.dllC:\Windows\SysWOW64\Macromed\Flash\pepflashplayer32_32_0_0_238.dll 当然，上面版本号会变化，但是 dll 所在路径基本是如上所示找到 flash 所在路径后，我们就可以提取文件放到我们的应用目录下了编译后就会成为应用安装包的一部分，这样就不需要用户手动安装 flash 了🔥 那么，在 electron 目录下应该如何引入呢？ # 问题解决将 flash 插件目录放到根目录的 lib 文件夹下12/lib/pepflashplayer64_32_0_0_238.dll/lib/pepflashplayer32_32_0_0_238.dll 接下来需要在主程序入口文件 /src/main/index.js 下进行引入也就是将这一句获取系统 flash 插件路径的代码1app.commandLine.appendSwitch('ppapi-flash-path', app.getPath('pepperFlashSystemPlugin')); 换为1234let flashPlugins = process.arch == 'x64' ? require('path').resolve(__dirname, '../../lib/pepflashplayer64_32_0_0_238.dll') : require('path').resolve(__dirname, '../../lib/pepflashplayer32_32_0_0_238.dll')app.commandLine.appendSwitch('ppapi-flash-path', flashPlugins); 如果使用的是 BrowserWindow：123456789101112131415161718192021const mainWindow = new BrowserWindow(&#123; height: 900, width: 1600, useContentSize: true, frame: false, center: true, fullscreenable: false, // 是否允许全屏 center: true, // 是否出现在屏幕居中的位置 title: 'Electron应用', backgroundColor: '#fff', // 背景色，用于transparent和frameless窗口 titleBarStyle: 'hidden', // 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等 resizable: false, // 是否允许拉伸大小 webPreferences: &#123; //配置web参数选项 plugins: true, //开启插件 webSecurity: false, //安全 defaultFontFamily: &#123; //字体相关 standard: "Microsoft YaHei", defaultEncoding: "utf-8" &#125; &#125;&#125;) 其中，plugins: true 是必须要配置的，这是告诉 electron 需要使用插件然后就是打包配置 package.json，在 build 项配置下面内容12345678910"build": &#123; …… …… "win": &#123; "icon": "build/icons/icon.ico", "extraResources": "./lib/*.dll" //将特定的文件排除，不打包在asar包内 &#125;, …… ……&#125; 至此，开发模式和生产模式下都是可以成功运行的以下是 /src/main/index.js 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import &#123; app, BrowserWindow &#125; from 'electron'import express from 'express'if (process.env.NODE_ENV !== 'development') &#123; global.__static = require('path').join(__dirname, '/static').replace(/\\/g, '\\\\')&#125;//解决flash本地file不安全问题，express用作本地服务器function localServer() &#123; let server = express(); server.use(express.static(__dirname)); server.listen(9080);&#125;if (process.env.NODE_ENV === "production") &#123; localServer();&#125;let mainWindowconst winURL = process.env.NODE_ENV === 'development' ? `http://localhost:9080` // : `file://$&#123;__dirname&#125;/index.html` //解决flash在file下不安全的问题 : `http://localhost:9080/index.html`let flashPlugins = process.arch == 'x64' ? require('path').resolve(__dirname, '../../lib/pepflashplayer64_32_0_0_238.dll') : require('path').resolve(__dirname, '../../lib/pepflashplayer32_32_0_0_238.dll')app.commandLine.appendSwitch('ppapi-flash-path', flashPlugins);app.commandLine.appendSwitch('ppapi-flash-version', '32.0.0.238');function createWindow () &#123; /** * Initial window options */ mainWindow = new BrowserWindow(&#123; height: 900, width: 1600, useContentSize: true, frame: false, center: true, fullscreenable: false, // 是否允许全屏 center: true, // 是否出现在屏幕居中的位置 title: 'Electron应用', backgroundColor: '#fff', // 背景色，用于transparent和frameless窗口 titleBarStyle: 'hidden', // 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等 resizable: false, // 是否允许拉伸大小 webPreferences: &#123; plugins: true, webSecurity: false, defaultFontFamily: &#123; standard: "Microsoft YaHei", defaultEncoding: "utf-8" &#125; &#125; &#125;) if (process.env.NODE_ENV == 'development') &#123; mainWindow.webContents.openDevTools() &#125; mainWindow.loadURL(winURL) mainWindow.on('closed', () =&gt; &#123; mainWindow = null &#125;)&#125;app.on('ready', createWindow)app.on('window-all-closed', () =&gt; &#123; if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; if (mainWindow === null) &#123; createWindow() &#125;&#125;) 🧐 End]]></content>
      <categories>
        <category>electron</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>elecrton-vue</tag>
        <tag>vue</tag>
        <tag>flash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa 实现 token 有效时间续期的思路]]></title>
    <url>%2F2019%2F09%2F06%2Fkoa_token%2F</url>
    <content type="text"><![CDATA[# 场景描述🍭 在前后端的交互中，无可避免的存在一些需要验证身份的请求。🍭 一般来说，使用 token 作为身份令牌可以实现身份验证的问题。🍭 以此同时，token 作为自带描述信息的无状态数据，唯一的判断标准就是生成 token 时设置的有效期时间，当超过有效期时则作废。🍭 我们在使用 APP 或 WEB 应用时，如果正在操作的时候，token 刚好过期了，那就出大问题了。🍭 所有的数据请求都会失败，给用户带来极其糟糕的体验。🍭 所以，如何才能让 token 进行续期呢？ # 处理思路🍤 因为 token 是无状态数据，一旦生成了，不能主动删除或者让它失效，唯一的就是等待有效期时间到。🍤 所以，我们会想到，在 token 过期时客户端携带新的 token 来访问数据接口，是不是就可以了呢。🍤 答案是的，那么现在需要解决的问题就是：121.怎么返回新的 token 给到客户端2.什么时候返回 token 使得用户登录状态得到续期 # 思路 通过设置返回头设置新 token 的值，客户端使用 axios 进行响应拦截判断是否有新 token 字段，有则保存起来。 如果用户在一定的 token 有效时间段期间（比如有效期时间的后半段）访问了数据接口，就应该对 token 进行续期。 # 代码实现🍥 本次项目采用的是 koa 基于 node 实现的 api 服务端。🍥 主要文件有两个，一个是入口文件 app.js，另一个是工具函数文件 token.js。🍥 完整 github 项目可以查看 PPAP.server。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//token.jsconst jwt = require('jsonwebtoken')const secret = 'secret'//判断token是否应该更新有效期（续期）const getTokenRenewStatus = () =&gt; &#123; //检测当前token是否到达续期时间段 let token = global.token let obj = jwt.verify(token, secret) //更新时间段在过期前3天 if(obj.exp - new Date().getTime()/1000 &gt; 60*60*24*3)&#123; return false &#125;else&#123; return true &#125;&#125;//获取一个期限为7天的tokenconst getToken = (payload = &#123;&#125;) =&gt; &#123; return jwt.sign(payload, secret, &#123; expiresIn: 60*60*24*7 &#125;);&#125;//重新生成一个期限为7天的tokenconst createNewToken = () =&gt; &#123; let token = global.token let obj = jwt.verify(token, secret) let payload = &#123; account: obj.account, password: obj.password &#125; return getToken(payload)&#125;//解析token为对象const parseToken = () =&gt; &#123; let token = global.token return jwt.verify(token, secret)&#125;module.exports = &#123; getTokenRenewStatus, getToken, createNewToken, parseToken&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//app.jsconst Koa = require('koa')const bodyParser = require('koa-bodyparser')const jwtKoa = require('koa-jwt') // 用于路由权限控制const app = new Koa()const tokenUtil = require('./util/token')const router = require('./router')//配置ctx.body解析中间件app.use(bodyParser())// 错误处理app.use((ctx, next) =&gt; &#123; //获取token，保存全局变量 if(ctx.request.header.authorization)&#123; global.token = ctx.request.header.authorization.split(' ')[1] &#125; return next().then(() =&gt; &#123; // 设置login、register接口，不需要判断token续期 if(ctx.path == '/user/login' || ctx.path == '/user/register')&#123; return &#125; //判断token是否应该续期（有效时间） if(tokenUtil.getTokenRenewStatus)&#123; //设置返回头header ctx.set(&#123; //客户端读取该属性即可获取新的token new_token: tokenUtil.createNewToken() &#125;) &#125; &#125;).catch((err) =&gt; &#123; if(err.status === 401)&#123; ctx.status = 401; ctx.body = &#123; status: 401, message: '未携带token令牌或者token令牌已过期' &#125; &#125;else&#123; throw err; &#125; &#125;)&#125;)const secret = 'secret'app.use(jwtKoa(&#123; secret: secret &#125;).unless(&#123; // 设置login、register接口，可以不需要认证访问 path: [ /^\/user\/login/, /^\/user\/register/ ]&#125;));//初始化路由中间件app.use(router.routes()).use(router.allowedMethods())//监听启动窗口app.listen(2333, () =&gt; console.log("koa is run on localhost:2333"))]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron 踩坑记录（一）]]></title>
    <url>%2F2019%2F08%2F09%2Felectron_note_1%2F</url>
    <content type="text"><![CDATA[# 场景描述构建 pc 客户端，采用 electron-vue 脚手架进行快速搭建环境。功能点在 web 端全部正常，移植代码到 electron 时出现问题的功能点有：121. rtmp 流媒体的播放 2. ant-design-vue UI 框架部分组件失效 🔥 播放器使用的是 vue-video-player，播放 rtmp 流需要使用 flash 技术。 # 问题解决简单记录问题关键123问题：pc 客户端 ant-design-vue 部分组件不能正常工作 原因：electron-vue 将它视为 webpack 的 externals 了，其中 UI 组件含有的 vue 文件没有被 vue-loader 正常编译，才导致功能失效解决：找到 .electron-vue/webpack.renderer.config.js 将 ant-design-vue 加入到白名单 whiteListedModules 🧐 electron 白名单配置123问题：pc 客户端引入 flash 之后还是不能正常播放 rtmp 流原因：electron 无法读取 vue-video-player 依赖安装的 videojs-flash 插件解决：单独安装 videojs-flash 插件为项目的依赖 npm i videojs-flash -S 123问题：编译成 pc 客户端后出现 vue-video-player 在即将 ready 这一步卡住原因：flash 加载的安全问题，不允许在 &quot;file://&quot; 协议下加载解决：在主线程里起一个 express 服务，使得页面运行在本地的端口服务即可]]></content>
      <categories>
        <category>electron</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>elecrton-vue</tag>
        <tag>vue</tag>
        <tag>flash</tag>
        <tag>vue-video-player</tag>
        <tag>rtmp</tag>
        <tag>ant-design-vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 重新加载当前组件]]></title>
    <url>%2F2019%2F07%2F25%2Fvue_reload_component%2F</url>
    <content type="text"><![CDATA[# vue 重新加载当前组件🍍 遇到问题的场景需要把当前组件完全还原成初始化状态，不要页面全部刷新🍍 例如：播放 rtmp 直播视频流的时候，点击暂停之后，想要恢复播放，需要重新载入当前播放器才行。🍍 情景：使用了 vue-video-player 播放器，点击视频播放界面，会暂停，因为播放的是 rtmp 直播流，想要恢复的话必须重新加载视频流以及加载 flash 等插件才行，此时简单的替换播放源 src 是不可行的，需要的是重新初始化当前播放器。 # 方案及结果🎨 刷新整个页面（用户体验不好）🎨 刷新单个组件12- 使用 v-if 控制组件的销毁和重建（本文用到方法）- 使用路由切换控制组件的销毁和重建 代码如下： 父组件 live 中包含子组件 player，使用中央事件总线作为父子通信方法。 👉 player.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class="container"&gt; &lt;a-spin tip="加载中..." :spinning="spinning"&gt; &lt;video-player class="vjs-custom-skin" ref="videoPlayer" :options="options" :playsinline="true" @play="onPlayerPlay($event)" @pause="onPlayerPause($event)" @ready="playerReadied" &gt;&lt;/video-player&gt; &lt;/a-spin&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import "videojs-flash";export default &#123; …… …… methods: &#123; // listen event onPlayerPlay(player) &#123; // console.log('player play 播放!', player) if(!this.isFirstPlay)&#123; //重新加载播放器 this.bus.$emit("refleshPlayer") &#125; this.isFirstPlay = false &#125;, onPlayerPause(player) &#123; // console.log('player pause 暂停', player) &#125;, // player is ready playerReadied(player) &#123; this.spinning = false &#125; &#125;&#125;&lt;/script&gt; 👉 live.vue123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class="main-container"&gt; &lt;a-row&gt; &lt;a-col :span="12" id="leftLayout"&gt; &lt;Player id="player" v-if="isFirstPlay"&gt;&lt;/Player&gt; &lt;Chatroom&gt;&lt;/Chatroom&gt; &lt;/a-col&gt; &lt;a-col :span="12"&gt; &lt;Webrtc&gt;&lt;/Webrtc&gt; &lt;/a-col&gt; &lt;/a-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Webrtc from 'component/webrtc'import Player from 'component/player'import Chatroom from 'component/chatroom'export default &#123; data()&#123; return &#123; isFirstPlay: true &#125; &#125;, mounted()&#123; this.bus.$on("refleshPlayer", () =&gt; &#123; this.isFirstPlay = false this.$nextTick(() =&gt; &#123; this.isFirstPlay = true &#125;) &#125;) &#125;, components: &#123; Webrtc, Player, Chatroom &#125;&#125;&lt;/script&gt; 🙃 再次点击播放，播放器组件就会重新加载初始化。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map 字符串数组/数字数组 快速转换]]></title>
    <url>%2F2019%2F06%2F27%2Fjs_map%2F</url>
    <content type="text"><![CDATA[12345let arr = [1, 2, 3];arr.map(String); //结果： ['1', '2', '3']let a = ['1', '2', '3'];a.map(Number); //结果：[1, 2, 3]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应路由参数的变化保持功能选中状态]]></title>
    <url>%2F2019%2F05%2F28%2Fvue_watch_%24route%2F</url>
    <content type="text"><![CDATA[# 背景在 vue + vue-router 的项目中，单页面路由的出现使得页面加载更加优雅。但与此同时，也会出现一些问题。 比如：121. 页面刷新如何保持功能选中状态2. 浏览器前进后退如何保持功能选中状态 😑 关于这两个问题，我们很容易想到通过监听路由地址来解决。 # 页面刷新对于问题 1 ，解决方法就是在页面加载时根据路由地址判断当前选择的是什么，从而激活对应的选中样式。如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; ... &lt;router-link to="/user/666"&gt; &lt;span class="posts" @click="selectNav('posts')" :class="&#123;active: navName === 'posts'&#125;" &gt;帖子 1&lt;/span&gt; &lt;/router-link&gt; &lt;router-link to="/user/666/followers"&gt; &lt;span class="followers" @click="selectNav('followers')" :class="&#123;active: navName === 'followers'&#125;" &gt;粉丝 2&lt;/span&gt; &lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; navName: "posts" &#125;; &#125;, mounted()&#123; this.refleshSelectStatus(this.$route.name) &#125;, methods: &#123; selectNav(str) &#123; this.navName = str; &#125;, refleshSelectStatus(route)&#123; switch (route) &#123; case 'UserPostList': this.navName = 'posts' break; case 'UserFollowerList': this.navName = 'followers' break; default: break; &#125; &#125; &#125; &#125;;&lt;/script&gt; 😑 很容易想到的解决方法。 # 浏览器前进后退对于问题 2 ，本次采用的是 history 的路由模式，一般来说，我们会想到监听浏览器前进后退事件，从而处理数据。然而，history 模式不比 hash 模式，需要监听 pushState 和 replaceState 行为，太过繁琐，参考 CSDN 文章 如何监听URL的变化。 最后，最简单合理的办法就是监听 $route 的变化 (我佛了😑)，如下：1234567891011&lt;script&gt; ... watch: &#123; $route(to, from)&#123; //to代表下一个的路由，from代表上一个路由 //监听路由变化，改变选中 this.refleshSelectStatus(to.name) &#125; &#125; ...&lt;/script&gt; PS：惯性思维有时候会令人深陷泥潭，换一种思维能更好的提高解决效率。当然，前提是对文档要熟悉（摊手😑） 更多路由使用方法参考官网 vue-router]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ref 与 $refs 对 dom 元素的操作]]></title>
    <url>%2F2019%2F05%2F14%2Fvue_%24refs%2F</url>
    <content type="text"><![CDATA[# 如何获取 v-for 渲染的多个不同 ref 的 dom🍍 在编写 vue 项目过程中，遇到了获取不到正确的 dom 元素节点的问题。 功能界面如图所示： 需要实现的是，点击每个播放器的右上角的关闭按钮，则关闭播放器。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div class="device-status"&gt; &lt;!-- 树组件 --&gt; &lt;Tree&gt;&lt;/Tree&gt; &lt;!-- 业务内容 --&gt; &lt;div class="content-container" ref="container"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125; (这是待删除文字) 具体看 status.vue 看代码写法&lt;/h1&gt; &lt;div&gt;&#123;&#123;buildings&#125;&#125;&lt;/div&gt; &lt;div class="video-box" ref="video1"&gt; &lt;Player src="https://gss3.baidu.com/6LZ0ej3k1Qd3ote6lo7D0j9wehsv/tieba-smallvideo/12846619_51a524dffce6834f1d221be2a1037834.mp4" poster="https://puui.qpic.cn/fans_admin/0/3_118841988_1557667793407/0" &gt;&lt;/Player&gt; &lt;i class="el-icon-circle-close" @click="close('video1')"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Tree from "component/checkbox-tree/tree";import Player from "component/player/player";export default &#123; data() &#123; return &#123; msg: "我是设备状态及控制组件", videoList: [ &#123; id: 1, index: 0, src: "https://gss3.baidu.com/6LZ0ej3k1Qd3ote6lo7D0j9wehsv/tieba-smallvideo/12846619_51a524dffce6834f1d221be2a1037834.mp4", poster: "https://puui.qpic.cn/fans_admin/0/3_118841988_1557667793407/0" &#125;, &#123; id: 2, index: 1, src: "https://cdn.theguardian.tv/webM/2015/07/20/150716YesMen_synd_768k_vp8.webm", poster: "https://ww1.sinaimg.cn/large/007i4MEmgy1g29h63wl0yj30et08c0tc.jpg" &#125; ] &#125;; &#125;, computed: &#123; buildings()&#123; return this.$store.state.buildingTree &#125; &#125;, components: &#123; Tree, Player &#125;, watch: &#123; buildings(newVal, oldVal)&#123; console.log("监听到树选中值变化",JSON.stringify(newVal)) //判断树数组的值，空则不作操作，否则带上树id //进行 http 请求获取数据 &#125; &#125;, methods: &#123; //关闭播放器 close(videoStr)&#123; //应该用数据驱动dom，这里直接操作了dom，不符合vue的理念，暂时 let video = this.$refs[videoStr] video.parentNode.removeChild(video) &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang="stylus"&gt;.device-status&#123; .el-tree&#123; width: 200px; height: calc(100vh - 70px); background-color: #f8f8f8; float: left; padding: 10px 20px; &#125; .content-container&#123; padding: 20px; margin-left: 200px; .video-box&#123; position: relative; width: 640px; display: inline-block; border: 5px solid #6699FF; margin: 40px 40px 10px 10px; .el-icon-circle-close&#123; position: absolute; top: -40px; right: -40px; color: #4A6495; font-size: 40px; opacity: 0.8; cursor: pointer; &#125; &#125; &#125;&#125;&lt;/style&gt; 至此代码功能正常，点击右上角关闭按钮，则移除播放器元素。 然后问题在于，播放器可能有多个存在，这时候，如何实现点击每个关闭按钮，关闭对应的播放器呢？ 尝试修改代码如下：12345678910&lt;template v-for="video in videoList"&gt; &lt;!-- 播放器组件，带关闭按钮 --&gt; &lt;div class="video-box" :ref="`video$&#123;video.id&#125;`" &gt; &lt;Player :src="video.src" :poster="video.poster" &gt;&lt;/Player&gt; &lt;i class="el-icon-circle-close" @click="close(`video$&#123;video.id&#125;`)"&gt;&lt;/i&gt; &lt;/div&gt;&lt;/template&gt; 12345678methods: &#123; //关闭播放器 close(videoStr)&#123; //应该用数据驱动dom，这里直接操作了dom，不符合vue的理念，暂时 let video = this.$refs[videoStr] video.parentNode.removeChild(video) &#125;&#125; 然后点击关闭按钮时，可以看到控制台报错： 提示不能获取未定义的属性，则表明该 dom 元素节点获取不对。 # 发现问题所在后面经过一番折腾，发现以上代码 this.$refs[videoStr] 获取的是一个 ref 等于 videoStr （此处为变量）的 dom 节点数组，不是单个 dom 节点元素！ 至此，踩坑这个之后，就明白了为什么获取不到对应的 dom 元素了。 代码修改如下即可：12345678methods: &#123; //关闭播放器 close(videoStr)&#123; //应该用数据驱动dom，这里直接操作了dom，不符合vue的理念，暂时 let video = this.$refs[videoStr][0] video.parentNode.removeChild(video) &#125;&#125; 功能实现后，再来拓展其他方法。 比如当 ref 的值一样，都为 videoBox 时：123456789&lt;template v-for="video in videoList"&gt; &lt;div class="video-box" ref="videoBox" &gt; &lt;Player :src="video.src" :poster="video.poster" &gt;&lt;/Player&gt; &lt;i class="el-icon-circle-close" @click="close(video.index)"&gt;&lt;/i&gt; &lt;/div&gt;&lt;/template&gt; 12345678methods: &#123; //关闭播放器 close(index)&#123; // 利用数组下标操作 let video = this.$refs.videoBox[index] video.parentNode.removeChild(video) &#125;&#125; 又或者不使用 ref 属性，改而为每个播放器元素赋值 id，也可：123456789&lt;template v-for="video in videoList"&gt; &lt;div class="video-box" :id="`video$&#123;video.id&#125;`"&gt; &lt;Player :src="video.src" :poster="video.poster" &gt;&lt;/Player&gt; &lt;i class="el-icon-circle-close" @click="close(`video$&#123;video.id&#125;`)"&gt;&lt;/i&gt; &lt;/div&gt;&lt;/template&gt; 12345678methods: &#123; //关闭播放器 close(videoId)&#123; // 利用数组下标操作 let video = document.querySelector(`#$&#123;videoId&#125;`) video.parentNode.removeChild(video) &#125;&#125; 官网概念： 总结： ref 相当于给元素或组件赋予一个 ID 引用，用来注册引用信息的，方便获取 dom 元素或获取组件实例。 使用场景：1231. ref 加在普通元素上，this.$refs.name 获取的是 dom 元素2. ref 加在子组件上，this.$refs.name 获取到的是组件实例，方便父组件使用子组件的所有方法3. 当 v-for 用于元素或组件，ref 获取的将是一组数组或 dom 节点 文章所说遇到的问题即是上述第三种情况。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 axios 请求出现 OPTIONS]]></title>
    <url>%2F2019%2F05%2F06%2Faxios_options%2F</url>
    <content type="text"><![CDATA[# 为什么 axios 先要请求 OPTIONS 再请求 POST🎨 最近在用 vue 重写一个以前的 angular + thinkjs 的项目，由于项目环境的前后端分离了，就出现了跨域问题，配置了一下 CORS 解决了跨域问题之后，又出现了 axios 请求发送两次的情况。 以登录功能为例，一共发送两个请求，第一个是 OPTIONS 请求，第二个是 POST 请求。 axios 配置如下：123456789101112131415161718192021222324import axios from 'axios'import qs from 'qs'const baseURL = 'http://localhost:8888'axios.interceptors.request.use((config) =&gt; &#123; if(config.method === 'post')&#123; config.data = qs.stringify(config.data) &#125; return config&#125;,(error) =&gt;&#123; return Promise.reject(error)&#125;)const request = axios.create(&#123; baseURL, headers: &#123; 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' &#125;, withCredentials: true // 允许携带cookie&#125;)export default request 执行功能请求的时候，控制台 XHR 请求如下： 一直处于 pending 状态，即等待中状态。 thinkjs 控制台显示请求时间如下： 👎 可以看到，OPTIONS 请求占用了差不多两分钟的时间之后，才进行 POST 请求，简直不能忍！！！ 所以，问题来了，为什么会出现两次请求呢？这个 OPTIONS 请求到底是何方神圣？ 首先我们来了解一下 CORS :CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 的局限性：CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于 IE10。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求。实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信。 CORS 的类别： 简单请求（simple request） 非简单请求（not-so-simple request） 简单请求（simple request）只要同时满足以下两大条件，就属于简单请求：1234请求方法是以下三种方法之一：- HEAD- GET- POST 123456HTTP 的头信息不超出以下几种字段：- Accept- Accept-Language- Content-Language- Last-Event-ID- Content-Type: 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 🙄 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。 Access-Control-Allow-Origin: 该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个 * ，表示接受任意域名的请求。 Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 Access-Control-Expose-Headers: 该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。 非简单请求（not-so-simple request）复杂跨域请求要满足以下：123- 请求方法不是 HEAD/GET/POST- POST 请求的 Content-Type 并非 application/x-www-form-urlencoded、multipart/form-data、text/plain- 请求设置了自定义的 header 字段 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 除了 Origin 字段，”预检”请求的头信息包括两个特殊字段： Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法。 Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 # 解决 axios 请求 OPTIONS 的方法😑 就是！把非简单请求转换为简单请求！！！ 简单粗暴~ 再次请求接口，发现 OPTIONS 请求已经没有了，直接 POST 请求响应速度杠杠的！ 🍰 终于解决了困扰了两天的跨域问题和 OPTIONS 验证了 😤 END]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
        <tag>options</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件版本命名规则]]></title>
    <url>%2F2019%2F04%2F17%2Fversion_number%2F</url>
    <content type="text"><![CDATA[#version_number_01{ border: 0 !important; /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #version_number_01:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } # 版本号命名规则🍰 软件版本号有四部分组成： 1234第一部分为主版本号 第二部分为次版本号 第三部分为修订版本号 第四部分为日期版本号加希腊字母版本号 🐱 主版本号（1）：当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。（另一种说法：产品的主体构件或构件之间的接口协议发生重大变动） 🐈 次版本号（0）：当功能点有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。（另一种说法：产品的数据结构发生变动） 🦁 修订版本号（2）：一般是 bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的 bug 即可发布一个修订版。此版本号由项目经理决定是否修改。（另一种说法：产品的数据结构未发生变动，仅修复 bug ） 🐯 日期版本号（20190417）：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。 🦄 希腊字母版本号（beta）：此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。 # 希腊字母所代表的版本阶段介绍🐔 Alpha 版： 也叫 α 版，此版本主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的 Bug 较多，需要继续修改。 🐓 Beta 版： 此版本相对于 α 版已经有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的 UI。 🐣 RC 版： 此版本已经相当成熟了，基本上不存在导致错误的 Bug，与即将发行的正式版相差无几，测试人员基本通过的版本。 🐤 Release 版： 此版本意味着“最终版本”、“上线版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release 不会以单词形式出现在软件封面上，取而代之的是符号( R )。]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取 v-html 渲染的富文本数据元素内容]]></title>
    <url>%2F2019%2F03%2F20%2Fvue_v-html%2F</url>
    <content type="text"><![CDATA[# 场景🍰 在业务中，往往有时候需要处理富文本格式的数据。 富文本格式数据： 带有html标签的数据 在传统的 web 开发下，当我们获取到数据，只要使用 append 或 innerHtml 将元素添加到 dom 中，再使用 document.querySelector() 即可获取 dom 元素。 而在 vue 中，页面渲染完毕，v-html 并没有触发页面渲染的重新执行，所以使用 document.querySelector() 方式是获取不到数据的，因为 dom 早在第一次加载时候就渲染完毕了，也就自然获取不到。 # 方案🍰 那么，在使用 vue 进行业务开发的场景下，如何获取使用 v-html 渲染的富文本格式下的 dom 元素呢 ？ 比如，富文本里包含：文字、图片等，业务场景是需要放大查看图片，就需要获取图片的地址。那么，如何获取图片地址呢？ 方法：在执行 v-html 命令的标签内，绑定点击事件，使用元素的 currentTarget 属性读取子元素的内容，即可实现对图片地址的获取。 代码：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;v-html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-html="content" @click="getDom($event)"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/vue/2.6.9/vue.min.js"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; content: `&lt;p&gt;这是一段文字&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://jwchan.cn/images/background_header.png"&gt;&lt;/p&gt;` &#125;, methods: &#123; getDom(e)&#123; console.log(e.currentTarget.lastChild.firstChild.src) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 🍳 就酱~]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于控制台打印点击事件目标元素的 currentTarget 为 null]]></title>
    <url>%2F2019%2F02%2F20%2FcurrentTarget_console_log%2F</url>
    <content type="text"><![CDATA[# 场景JS 代码：12345const target = document.getElementById('target');target.addEventListener('click', function (e) &#123; console.log(e); console.log(e.currentTarget);&#125;); 控制台输出：1234MouseEvent &#123;isTrusted: true, screenX: 149, screenY: 253, clientX: 149, clientY: 131, … currentTarget: null, …&#125;&lt;div id="target"&gt;&lt;/div&gt; 打印出来的 e 对象，可以看到 currentTarget 的值是 null，但是直接访问的话，却发现它其实是有值的 # 原因在这种情况下，我们在调用时 console.log(e)，currentTarget 属性中有一个 DOM 元素。 但是，事实上 e.currentTarget 是一个瞬态值，它将在完成事件传播后重置为 null，所以当我们在 e.currentTarget 运行后一帧去访问它时，它已经变为 null 了。 如果需要传递 currentTarget，应该在程序运行时将它保存到另一个变量中。 参考链接 https://segmentfault.com/q/1010000015625042 https://github.com/vuejs/vue/issues/6867 https://stackoverflow.com/questions/26496176/when-logging-an-event-object-currenttarget-is-null-but-when-logging-event-curr]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现平滑滚动回到顶部]]></title>
    <url>%2F2019%2F01%2F27%2Fback_to_top%2F</url>
    <content type="text"><![CDATA[# 场景🍰 实现页面滚动到一定位置，出现返回顶部图标🍰 点击图标实现页面平滑滚动返回顶部 # 方案采用 window.requestAnimationFrame( ) 实现 window.requestAnimationFrame( ) 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 当你需要更新屏幕画面时就可以调用此方法在浏览器下次重绘前执行回调函数 🍰 核心功能代码： 123456789function smoothscroll()&#123; var currentScroll = document.documentElement.scrollTop || document.body.scrollTop; if (currentScroll &gt; 0) &#123; //告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画 window.requestAnimationFrame(smoothscroll); //进行页面位置重绘 window.scrollTo (0,currentScroll - (currentScroll/10)); &#125; &#125; 🍰 完整代码： &lt;!DOCTYPE html&gt; &lt;html lang="Zh-cn"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;平滑滚动回到顶部&lt;/title&gt; &lt;style&gt; body{ height: 20000px; background-image: url('https://jwchan.cn/images/background_header.png'); background-position: center 0; background-size: contain; background-repeat: repeat; } #kotori{ position: fixed; bottom: -10px; left: -10px; height: 70px; width: 70px; cursor: pointer; transition: 0.2s all; display: block; z-index: 100; } #kotori:hover{ transform: translate(10px,-10px) } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id="kotori" src="https://jwchan.cn/images/kotori.png" onclick="smoothscroll()"&gt; &lt;script&gt; //监听页面滚动 window.addEventListener("scroll",handleScroll) //滚动条滚动事件处理函数 function handleScroll(){ //获取滚动高度 var osTop = document.documentElement.scrollTop || document.body.scrollTop; //可视区域高度 var clientHeight = document.documentElement.clientHeight; //如果滚动高度大于可视区域高度，则显示回到顶部按钮 if(osTop &gt;= clientHeight){ document.querySelector('#kotori').style.display = 'block'; }else{ //否则隐藏 document.querySelector('#kotori').style.display = 'none'; } } //回到顶部功能函数 function smoothscroll(){ var currentScroll = document.documentElement.scrollTop || document.body.scrollTop; if (currentScroll &gt; 0) { window.requestAnimationFrame(smoothscroll); window.scrollTo (0,currentScroll - (currentScroll/10)); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 🍰 这是相对顺滑的平滑滚动最简单的实现了 ~🍰 实现效果可参考本网站的左下角的 kitoro 酱 ~]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 git 向开源项目提交 pull request]]></title>
    <url>%2F2019%2F01%2F20%2Fgit_pull_request%2F</url>
    <content type="text"><![CDATA[#Pull Request 是什么⛏️ Pull Request 是一种通知机制你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request ⛏️ Pull Request 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码 ⛏️ 简单的说是在自己本地仓库修改代码，提交到自己远程仓库，提交 PR 后被接受后，再会被合并到 master #具体流程1、fork将项目 fork 到自己的仓库中，以 vue-clicli 为例 进入到 vue-clicli 的 Github 项目中，点击右上角的 fork，稍等片刻，此项目便会出现在自己的仓库中 进到自己 fork 的项目中，就能看到 Clone or download 按钮，复制一下 SSH 链接或者 HTTPS 链接 通过上面的步骤，已经将远程仓库建好了 2、clone将刚才 fork 过来的项目 clone 到本地，用的是你刚才复制的 SSH 链接或者 HTTPS 链接1git clone https://github.com/acgzone/vue-clicli.git 进到 vue-clicli 目录中，试试跑一下 git status，会提示现在是 master 分支 用 git remote -v 命令，可以看到此时只与自己的远程仓库建立了连接 还需要与上游建立连接，这里上游指的是一开始 fork 的那个项目源，以 vue-clicli 为例，执行如下命令：1git remote add upstream https://github.com/acgzone/vue-clicli.git 再用 git remote -v 可以看到 接下来就能创建分支了 3、创建分支继续运行命令：1git checkout -b dev 这个命令的意思是创建一个叫 dev 的分支，运行这个命令后 bash 将自动切换到新的分支下 4、修改代码自行修改代码，完成开发等等 5、提交可以先使用 git status 来查看有哪些文件被修改了 然后再 git add ***.vue 将要提交的文件都加上 然后再 git commit -m &quot;modify XX&quot;，需要注意的是 git commit 只是把修改的代码提交到当前分支 ( 当前分支是 dev，而不是 master ) ，&quot;modify XX&quot; 是本次提交的简单说明 然后再 git push origin dev，这一步才是将当前分支推送到自己的远程仓库 这时，在自己的远程仓库便能看刚才 push 上去的分支了 #提交 PR找到 New pull request，需要注意的是 compare 处选择刚才提交上来的分支 然后点 Create pull request 写好名字，写好说明，提交 🎨 PR 创建后，就等着管理者是否接受该 PR 了 #关于 check 不通过的问题github 有代码自己编译和 check 机制，在你提交 pr 的时候，项目可能已经有了比较大的变更 ( 每天都有世界各地的 coder 提 pr )，而你没有将分支保持与项目同步，所以有可能会导致 check 失败，pr 被无视 还记得我们在自己本地有一个 master 分支，然后又拉了一个 dev 分支，然后在 dev上进行修改，提交的也是 dev，然后又想起了之前有一步是”与上游建立连接”，说到你可能已经知道了 master 的作用 —— 用于远程代码同步 所以每次提交 pr 前，都要先从做代码同步。过程如下： 先 git fetch upstream 再 git rebase upstream/master 再 git push origin master push 完后，远程仓库便可看到你的 branch 版本和 master 分支一致了，否则会显示与 master 相差了多少次 commit 🍭 注：此处 branch 指的是你自己的远程仓库，master 指的是 fork 的项目的仓库 🌥️ 做完这些操作，就可以回到之前的步骤来操作了 p img{ margin-left:0 !important; }]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 apicloud 下关闭 Win 页面失效问题]]></title>
    <url>%2F2019%2F01%2F16%2Fapicloud_closeWin%2F</url>
    <content type="text"><![CDATA[#场景🌈 在使用 apicloud 开发相关应用的时候，经常会遇到打开一个新的 Window 页面，同时需要把其他 Window 或 Frame 页面关闭的情况。以下是官网 api 文档的描述： closeWin 方法可以关闭 Window，但注意，若当前正在进行 openWin、closeWin 等带动画过渡的 Window 操作，调用此方法会失效。 #探索根据官方文档说明，想到的解决办法就是：当触发 openWin 方法打开新页面时，利用 setTimeout 方法延迟执行关闭旧页面的 Window 和 Frame，或者直接把 openWin 的切换动画禁掉，按理说这两种解决方法是可行的，但是，当操作频繁且快速切换的时候，往往就会出现失灵的情况。🍰 以退出登录功能为例，代码如下：123456789101112131415161718192021222324252627282930function logout()&#123; api.openWin(&#123; name: 'login', animation: &#123; type: 'fade', duration: 300 &#125; &#125;) setTimeout(function()&#123; api.closeWin(&#123; name: 'moreInfo', animation: &#123; type: 'none' &#125; &#125;) &#125;,300) setTimeout(function()&#123; api.closeWin(&#123; name: 'teacherIndex', animation: &#123; type: 'none' &#125; &#125;) &#125;,400) setTimeout(function()&#123; api.closeFrameGroup(&#123; name: 'group' &#125;); &#125;,500)&#125; 以上方法，实践证明，无法解决打开新的 Win 页面后关闭旧的 Win 页面的问题。后面经过探索后，最终找到了解决方案。 #方案🚀 apicloud 官方文档有提供一个 viewappear 事件： viewappear 是 Window 显示到屏幕的事件，标志当前 Window 已经动画结束，并且完全显示到屏幕上。viewappear 事件作用对象只是 Window，Frame 的显示不会收到事件。 所以，回到问题上，我们在新 Window 页面里进行事件监听，然后在回调函数里执行页面关闭操作即可。还是以退出登录功能为例，新页面为登录页面 login。🍰 login 页面代码如下：12345678910111213141516171819202122232425262728293031323334//事件代表当前 Window 已经动画结束，并且完全显示到屏幕上api.addEventListener(&#123; name: 'viewappear'&#125;, function(ret, err)&#123; setTimeout(function() &#123; api.closeWin(&#123; name: 'moreInfo', animation: &#123; type: 'none' &#125; &#125;); &#125;, 200) setTimeout(function()&#123; api.closeWin(&#123; name: 'myInfo', animation: &#123; type: 'none' &#125; &#125;); &#125;,400) setTimeout(function()&#123; api.closeWin(&#123; name: 'teacherIndex', animation: &#123; type: 'none' &#125; &#125;); &#125;,600) setTimeout(function()&#123; api.closeFrameGroup(&#123; name: 'group' &#125;); &#125;,800)&#125;); 🍭 这样的话，就能在新的 Window 页面打开动画结束之后，精确执行关闭其他 Window 页面和 Frame 页面的方法啦 ~]]></content>
      <categories>
        <category>混合APP</category>
      </categories>
      <tags>
        <tag>apicloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非模块化下实现简单 vue-router 应用]]></title>
    <url>%2F2019%2F01%2F10%2Fvue_router_nomodular%2F</url>
    <content type="text"><![CDATA[#场景一般情况下，我们使用工程化构建应用，需要的是导入 Vue 和 VueRouter，然后要调用 Vue.use(VueRouter)那么，如果是非模块化 vue 使用 vue-router 应用的实现，是怎么样的呢？ 🍭 下面是贴代码时间：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190&lt;!DOCTYPE html&gt;&lt;html lang="Zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue-router&lt;/title&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; body,html&#123; text-align: center; &#125; .a-link&#123; display: block; padding: 10px; width: 100px; margin: 10px auto; text-decoration: none; background-color: #009688; color: #fff; &#125; .a-link:hover&#123; background-color: #F2AA24; &#125; /*没有数据，正在加载*/ .loading&#123; text-align: center; padding-top: 10px; padding-bottom: 10px; display: flex; flex-direction: column; align-items: center; &#125; .loading img&#123; height: 40px; width: 40px; animation: que 1.6s linear infinite; &#125; @keyframes que&#123; /*以百分比来规定改变发生的时间 也可以通过"from"和"to",等价于0% 和 100%*/ 0%&#123; /*rotate(2D旋转) scale(放大或者缩小) translate(移动) skew(翻转)*/ transform: rotate(0deg); &#125; 100%&#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app" v-cloak&gt; &lt;h1&gt;Hello SPA App!&lt;/h1&gt; &lt;!--全局组件--&gt; &lt;hello&gt;&lt;/hello&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/photo" class="a-link"&gt;Go to Photo&lt;/router-link&gt; &lt;router-link to="/album" class="a-link"&gt;Go to Album&lt;/router-link&gt; &lt;router-link to="/user" class="a-link"&gt;Go to User&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;script&gt; //全局组件 Vue.component('hello',&#123; data()&#123; return &#123; count: 0 &#125; &#125;, template: `&lt;button @click="count++"&gt;you clicked me &#123;&#123; count &#125;&#125; times` &#125;) // 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter) // 1. 定义 (路由) 组件。（组件配置对象） // 可以从其他文件 import 进来 const Photo = &#123; data()&#123; return &#123; photos: [] &#125; &#125;, template: `&lt;div&gt; &lt;div class='loading' v-if="!photos.length"&gt; &lt;img src='./image/loading.png'&gt; &lt;/div&gt; &lt;div v-for="photo in photos"&gt; &lt;div&gt;&#123;&#123;photo.title&#125;&#125;&lt;/div&gt; &lt;img :src="photo.thumbnailUrl"&gt; &lt;img :src="photo.url"&gt; &lt;/div&gt; &lt;/div&gt;` , mounted()&#123; fetch('http://jsonplaceholder.typicode.com/photos?id=1') .then(response =&gt; response.json() ).then(json =&gt; &#123; this.photos = json console.log(this.photos) &#125;) &#125; &#125; const Album = &#123; data()&#123; return &#123; albums: [] &#125; &#125;, template: `&lt;div&gt; &lt;div class='loading' v-if="!albums.length"&gt; &lt;img src='./image/loading.png'&gt; &lt;/div&gt; &lt;div v-for="album in albums"&gt; &lt;div&gt;&#123;&#123;album.title&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` , mounted()&#123; fetch('http://jsonplaceholder.typicode.com/albums?userId=1') .then(response =&gt; response.json() ).then(json =&gt; &#123; this.albums = json console.log(this.albums) &#125;) &#125; &#125; const User = &#123; data()&#123; return &#123; users: [] &#125; &#125;, template: `&lt;div&gt; &lt;div class='loading' v-if="!users.length"&gt; &lt;img src='./image/loading.png'&gt; &lt;/div&gt; &lt;div v-for="user in users"&gt; &lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` , mounted()&#123; fetch('http://jsonplaceholder.typicode.com/users') .then(response =&gt; response.json() ).then(json =&gt; &#123; this.users = json console.log(this.users) &#125;) &#125; &#125; // 2. 定义路由 // 每个路由应该映射一个组件。 其中"component" 可以是 // 通过 Vue.extend() 创建的组件构造器， // 或者，只是一个组件配置对象。 const routes = [ &#123; path: '/photo', component: Photo &#125;, &#123; path: '/album', component: Album &#125;, &#123; path: '/user', component: User &#125; ] // 3. 创建 router 实例，然后传 `routes` 配置 const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes &#125;) // 4. 创建和挂载根实例。 // 记得要通过 router 配置参数注入路由， // 从而让整个应用都有路由功能 const app = new Vue(&#123; router &#125;).$mount('#app') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 🍳 以上，单个 HTML 页面就能实现 (≖ᴗ≖)✧最简单的非模块化 vue 路由应用了~~~]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hover 伪类改变另一个元素的样式]]></title>
    <url>%2F2019%2F01%2F06%2Fcss_hover%2F</url>
    <content type="text"><![CDATA[#功能使用 css 的 hover 伪类改变另一个元素的样式比如本博客友链页面，鼠标悬停 a 标签，实现子元素 img 标签进行旋转动画使用 js 触发动态添加属性可以实现，但最简便的办法是 css hover举个栗子： 鼠标悬停在 A 元素时，改变 B 元素样式 #场景🍭情景 1 ：B 元素是 A 元素的子元素1234567891011&lt;!--情景1--&gt;&lt;div class="A"&gt; &lt;div class="B"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .A:hover .B&#123; /*鼠标经过A元素时，B元素背景会变成黑色*/ background:#000; &#125;&lt;/style&gt; 🍭情景 2 ：A 元素与 B 元素相邻且 A紧接着 B 如果 B 元素在 A 元素之前，是无法使用 + 选择符的 12345678910&lt;!--情景2--&gt;&lt;div class="A"&gt;&lt;/div&gt;&lt;div class="B"&gt;&lt;/div&gt;&lt;style&gt; .A:hover +.B &#123; /*鼠标经过A元素时，B元素背景会变成黑色*/ background:#000; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google DevFest 2018]]></title>
    <url>%2F2019%2F01%2F02%2FGDG2018%2F</url>
    <content type="text"><![CDATA[#GDG2018_01, #GDG2018_02, #GDG2018_03, #GDG2018_04, #GDG2018_05, #GDG2018_06, #GDG2018_07, #GDG2018_08, #GDG2018_09, #GDG2018_10{ border: 0 !important; /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #GDG2018_01:hover, #GDG2018_02:hover, #GDG2018_03:hover, #GDG2018_04:hover, #GDG2018_05:hover, #GDG2018_06:hover, #GDG2018_07:hover, #GDG2018_08:hover, #GDG2018_09:hover, #GDG2018_10:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } #什么是 GDGGDG 是 Google Developer Groups (谷歌开发者社区)的缩写，也是现在项目的正式名称。GDG 是谷歌开发者部门发起的开发者社区全球项目，是面向对 Google 和开源、开放技术感兴趣的公益性开发者社区，内容涵盖 Web、Android 和其它 Google API 等。目前在全球已有500多个 GDG 社区，中国已有超过 20个 GDG 社区。GDG 主要面向开发者、设计师、创业者、大学生等软件从业人员，是一个开放和自由的社区。 #关于活动12月23号的 Google DevFest 2018广州国际嘉年华，是我第一次去参加的开发者大会，因为之前有关注 Flutter 技术，所以在得到 GDG 在广州举办活动的消息后，就赶紧报了个名，主要关注 Flutter 技术相关，当然，大会议程上的其他相关分享也是相当令人激动的。当天还有现场的 code lab，有 Flutter 和 Tensorflow 这两个，现场编程交流，代码实验室，完美诠释talk is cheap，show me your code。这次来的主要目的是拓展视野，了解前沿技术。本文作个记录，希望下一年可以参加 code lab？]]></content>
      <categories>
        <category>活动</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 实现 data 数据与视图更新]]></title>
    <url>%2F2019%2F01%2F02%2Fvue_data_update%2F</url>
    <content type="text"><![CDATA[#场景vue 数据 data 更新了，但是视图没有更新其中缘由在于对 vue 的响应式原理的理解 #追踪变化把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 #声明响应性属性在 Vue 中，一般只有在 data 选项中声明的属性（或者是属性的属性）才是具有响应特性的。如果需要在 data 选项之外对已有属性添加具有响应特性的属性，需要用到 Vue 的 set 方法。1234567var vm = new Vue(&#123; data: &#123; a: &#123; //a就是根级属性，不可动态添加 b: 0 //b就是属性的属性，可以动态添加 &#125; &#125;&#125;) Vue 不允许动态添加根级响应式属性，必须在初始化实例前声明根级响应式属性，哪怕只是一个空值：123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message`vm.message = 'Hello!' 何为响应特性？就是当我们更改 data 中的值的时候，HTML 与之绑定的部分会随之更新的特性。 #数组更新检测🍳 #变异方法替换数组 Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse() 打开控制台，然后用 items 数组调用变异方法：example1.items.push({ message: &#39;Baz&#39; }) 。 🍳 #非变异方法替换数组 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 🍳 #注意事项 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 举个栗子：1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：12// Vue.setVue.set(vm.items, indexOfItem, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice：1vm.items.splice(newLength) #对象更新检测还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, 'age', 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做：1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) #数据响应式的几个例子12345678910var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 a 就是在 data 中声明的具有响应特性的属性，而 b 就不是。12345678910111213var vm = new Vue(&#123; data: &#123; a: &#123; a1:'' &#125; &#125;, methods: &#123; change：function()&#123; this.a.a1 = "text1" //a1就是响应式的 this.a.a2 = "text2" //a2就不是响应式的 &#125; &#125;&#125;) a2 虽然不是响应式的，但它却是可以在 HTML 部分被渲染更新出来。这里就是一个比较容易掉进去的坑。由于 Vue 是异步执行 DOM 更新，虽然更新的动作是由 this.a.a1 = &quot;text1&quot; 触发，可动作的完成是在 this.a.a2 = &quot;text2&quot; 之后，下面有详细解析。123456789101112131415161718192021var vm = new Vue(&#123; data: &#123; a: &#123; a1:'' &#125; &#125;, methods: &#123; change: function () &#123; this.a.a1 = "text1" //a1就是响应式的 this.a.a2 = "text2" //a2就不是响应式的 var that = this; setTimeout(function () &#123; that.a.a3 = 'new text'; //这里与a2是相同的，区别在于这里的a3并不会被渲染到DOM中 that.$set(that.a, 'a4', 'new text'); //这是正确的添加属性的方法 that.a = &#123; //这种写法与a2不同，a5可以被更新到DOM中 a5: 'hahaha' &#125; &#125;, 300); &#125; &#125;&#125;) #异步更新带来的数据响应式误解异步数据的处理基本是一定会遇到的，处理不好就会遇到数据不更新的问题，但有一种情况是在未正确处理的情况下也能正常更新，这就会造成一种误解，详情如下所示：1234567891011121314151617new Vue(&#123; el: '#app', data: &#123; dataObj: &#123;&#125; &#125;, ready: function () &#123; var self = this; /** * 异步请求模拟 */ setTimeout(function () &#123; self.dataObj = &#123;&#125;; self.dataObj['text'] = 'new text'; &#125;, 3000); &#125;&#125;) 上面的代码非常简单，我们都知道 vue 中在 data 里面声明的数据才具有响应式的特性，所以我们一开始在 data 中声明了一个 dataObj 空对象，然后在异步请求中执行了两行代码，如下：12self.dataObj = &#123;&#125;; self.dataObj['text'] = 'new text'; 首先清空原始数据，然后添加一个 text 属性并赋值。到这里为止一切都如我们所想的，数据和模板都更新了。 那么问题来了，dataObj.text 具有响应式的特性吗？ 模板更新了，应该具有响应式特性，如果这么想那么你就已经走入了误区，一开始我们并没有在 data 中声明 .text 属性，所以该属性是不具有响应式的特性的。 但模板切切实实已经更新了，这又是怎么回事呢？ 那是因为 vue 的 dom 更新是异步的，即当 setter 操作发生后，指令并不会立马更新，指令的更新操作会有一个延迟，当指令更新真正执行的时候，此时 .text 属性已经赋值，所以指令更新模板时得到的是新值。具体流程如下所示： self.dataObj = { }; 发生 setter 操作 vue 监测到 setter 操作，通知相关指令执行更新操作 self.dataObj[&#39;text&#39;] = &#39;new text&#39;; 赋值语句 指令更新开始执行 所以真正的触发更新操作是 self.dataObj = { }; 这一句引起的，所以单看上述例子，具有响应式特性的数据只有 dataObj 这一层，它的子属性是不具备的。 注：其实 vue 文档中已经有说明，对于新增以及删除的属性，vue 是无法监测到的。123456var a = &#123;&#125;;a.b = 0; //新增b属性a = &#123; c: 0&#125;; //更改a属性的值 上述两种赋值方式对 vue 造成的影响是不同的。 对比示例：12345678910111213141516new Vue(&#123; el: '#app', data: &#123; dataObj: &#123;&#125; &#125;, ready: function () &#123; var self = this; /** * 异步请求模拟 */ setTimeout(function () &#123; self.dataObj['text'] = 'new text'; &#125;, 3000); &#125;&#125;) 上述例子的模板是不会更新的。 🍭 Vue.$set 通过 $set 方法可以将添加一个具备响应式特性的属性，并且其子属性也具备响应式特性，但是必须是新属性才可以，如果是本身已有的属性该方法是不起作用的。1234567891011121314151617181920212223242526new Vue(&#123; el: '#app', data: &#123; dataObj: &#123;&#125; &#125;, ready: function () &#123; var self = this; /** * 异步请求模拟 */ setTimeout(function () &#123; var data = &#123; name: 'xiaofu', age: 18 &#125;; var data01 = &#123; name: 'yangxiaofu', age: 19 &#125;; self.dataObj['person'] = &#123;&#125;; self.$set('dataObj.info', data); self.$set('dataObj.person', data01); &#125;, 3000); &#125;&#125;) 如上所示，.person 属性是不具备响应式特性的。 .img_v-bind{ margin-top: 40px !important; transition: 0.2s all; } .img_v-bind:hover{ transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; }]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-bind 动态拼接参数]]></title>
    <url>%2F2018%2F12%2F29%2Fvue_v-bind%2F</url>
    <content type="text"><![CDATA[#场景在业务开发中常常需要对元素属性进行动态绑定比如 v-for 下遍历 img 绑定 src 地址传统方法用的是拼接 dom 元素字符串，再把字符串插入到文档流里，对于使用 vue，我们不必再频繁地处理 dom我们可以使用 v-bind 来处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错，需要处理妥当。 #示例动态拼接，以 v-for 为例： &lt;div id="app"&gt; &lt;div v-for="(item,index) in items" :key="index"&gt; &lt;img :src="'http://image.baidu.com'+item.thumbnail" alt="图片"&gt; &lt;/div&gt; &lt;a :href="'http://user.baidu.com?uid='+uid"&gt;跳转用户界面的链接&lt;/a&gt; &lt;a v-bind:href="url"&gt;github&lt;/a&gt; &lt;/div&gt; &lt;script&gt; new vue({ el: '#app', data: { items: [{ name: 'baidu', thumbnail: '/public/123456.jpg' }, { name: 'github', thumbnail: '/public/234567.jpg' }], uid: 123, url: 'https://github.com' } }) &lt;/script&gt; 🍳 以上示例是动态拼接字符串的正确方式: 是 v-bind 的缩写，指令可以接一个&quot;参数&quot;，这个&quot;参数&quot;在指令后面以冒号表示，如 &lt;a v-bind:href=&quot;url&quot;&gt;github&lt;/a&gt; 的 url 就是参数，与 vue 实例数据绑定。 🍭 谨记：v-bind 属性内必须为合法的 JavaScript 表达式无论是拼接字符串还是三目运算表达式，返回的都是合法 JavaScript 表达式返回的结果。v-bind 表达式结果的类型除了字符串之外，还可以是对象或数组。 🐯 点击查看 @v-bind 更多特性与用法 yo ~ .img_v-bind{ margin-top: 40px !important; transition: 0.2s all; } .img_v-bind:hover{ transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; }]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Axios Post 请求的坑]]></title>
    <url>%2F2018%2F12%2F25%2Faxios_post%2F</url>
    <content type="text"><![CDATA[Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 踩坑按照 axios 官网例子使用 axios.post 发起请求传递 json，后台接受到的数据为空浏览器报错，然后使用 restlet 请求却可以正常返回数据经过一波操作之后，最后发现是因为 axios 的默认提交方式是 application/json 这种而后台接口的处理的是常见的 post 编码 application/x-www-form-urlencoded 这种后台接收到的是经过序列化后的 json 字符串，所以没办法读取值出来所以，问题找出来了，就可以解决问题了 解决既然我们知道 axios post 方法默认使用 application/json 格式编码数据，那么解决方案就有两种，一是后台改变接收参数的方法，另一种则是将 axios post 方法的编码格式修改为 application/x-www-form-urlencoded，这样就不需要后台做什么修改了。 第一种 后台解析对接收到的参数进行解析，生成 json 对象再对 json 对象进行处理以 php 为例123$content = $GLOBALS["HTTP_RAW_POST_DATA"]; #获取原始数据$re = json_decode($content); #生成json对象...... 这种方法最为简便，不过……如果接口已经写好了，且接口很多，要改的话，还是要花点时间…… 第二种 前端处理数据在查阅文档之后，发现 axios 允许在向服务器发送前，修改请求数据增加 transformRequest 方法参数：1234567891011121314&#123; url: '/user', // url 是用于请求的服务器 URL method: 'post', // method 是创建请求时使用的方法,默认是 get // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;],], 下面是处理代码：12345678910&#123; //对提交的数据格式进行转换 transformRequest: [function (data) &#123; let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;],&#125; 完整代码是：123456789101112131415161718axios(&#123; method: 'post', url: 'https://api.github.com/user', #接口地址，仅参考 data: &#123; action: "getUserMessage", userId: 100 &#125;, //对提交的数据格式进行转换（post方法的坑） transformRequest: [function (data) &#123; let ret = '' for (let it in data) &#123; ret += encodeURIComponent(it) + '=' + encodeURIComponent(data[it]) + '&amp;' &#125; return ret &#125;]&#125;).then( response =&gt; &#123; console.log(response.data)&#125;) 🎄然后就可以正常获取数据了~最后，圣诞节快乐🎅~ 附：当参数是 JSON 字符串时，默认的 Content-Type 是 application/x-www-form-urlencoded12345678910axios.post('/user', JSON.stringify(&#123; firstName: 'Fred', lastName: 'Flintstone' &#125;)) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error);&#125;); 此时传递的参数是 Form Data 格式 key : value1&#123;"firstName":"Fred","lastName":"Flintstone"&#125;: 如上。这是一个无效的数据，key为 {&quot;firstName&quot;:&quot;Fred&quot;,&quot;lastName&quot;:&quot;Flintstone&quot;}，value 为空。 🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 实现代码托管]]></title>
    <url>%2F2018%2F12%2F20%2Fgit_command%2F</url>
    <content type="text"><![CDATA[#git_command{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #git_command:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 前置条件: 在 github 上新建仓库，本地与远端已实现身份认证 🔶 第一步: 建立 git 仓库(本地)1git init 🔶 第二步: 将项目所有文件添加到待上传列表中1git add . 🔶 第三步: 将 add 的文件 commit 到本地仓库(并添加注释)1git commit -m &quot;注释语句&quot; 🔶 第四步: 将本地仓库关联到 github 远程仓库1git remote add origin https://github.com/jwchan1996/pizza-app.git #仓库地址 🔶 第五步: 将代码上传到 github 远程仓库(推送)12# 使用 -u 代表指定默认主机，这样以后就可以不加任何参数使用 git pull 与 git pushgit push -u origin master 🌖 注意: 多人协作每次同步代码需要先将代码拉下来(拉取) 👉 首先将代码提交到本地仓库12git add .git commit -m &quot;注释语句&quot; 👉 将远程代码拉取下来1git pull origin master 👉 然后再将本地仓库代码上传1git push origin master 至此，github 代码托管就完成啦(๑&gt;؂&lt;๑） 🌘 附: Git基本常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mkdir XX #创建一个空目录 XX指目录名pwd #显示当前目录的路径。git init #把当前的目录变成可以管理的git仓库，生成隐藏.git文件。git add XX #把xx文件添加到暂存区去。git commit –m “XX” #提交文件 –m 后面的是注释。git status #查看仓库状态git diff XX #查看XX文件修改了那些内容git log #查看历史记录git reset --hard HEAD^ 或者 git reset --hard HEAD~ #回退到上一个版本git reset –hard HEAD~100 #回退到100个版本cat XX #查看XX文件内容git reflog #查看历史记录的版本号idgit checkout -- XX #把XX文件在工作区的修改全部撤销。git rm XX #删除XX文件git remote add origin https://github.com/jwchan1996/pizza-app.git #关联一个远程库git push –u(第一次要用-u 以后不需要) origin master #把当前master分支推送到远程库git clone https://github.com/jwchan1996/pizza-app.git #从远程库中克隆git checkout –b dev #创建dev分支 并切换到dev分支上git branch #查看当前所有的分支git checkout master #切换回master分支git merge dev #在当前的分支上合并dev分支git branch –d dev #删除dev分支git branch name #创建分支git stash #把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list #查看所有被隐藏的文件列表git stash apply #恢复被隐藏的文件，但是内容不删除git stash drop #删除文件git stash pop #恢复文件的同时 也删除文件git remote #查看远程库的信息git remote –v #查看远程库的详细信息git push origin master #Git会把master分支推送到远程库对应的远程分支上 完毕！]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11月份 / Summary]]></title>
    <url>%2F2018%2F12%2F01%2Fsummary_201811%2F</url>
    <content type="text"><![CDATA[#summary_201811_01, #summary_201811_02, #summary_201811_03, #summary_201811_04, #summary_201811_05, #summary_201811_06, #summary_201811_07, #summary_201811_08, #summary_201811_09{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #summary_201811_01:hover, #summary_201811_02:hover, #summary_201811_03:hover, #summary_201811_04:hover, #summary_201811_05:hover, #summary_201811_06:hover, #summary_201811_07:hover, #summary_201811_08:hover, #summary_201811_09:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 雉青十一，渐入佳境 十一月份，是梳理的月份，是持续学习与渴望coding的。 关于产品 解决了用户需求，实现了产品目标对用户和公司来说是个好产品。而对于产品本身，应该从设计实现的每个细节角度来评判其是不是个好产品。每个功能是不是以最优的用户体验和技术实现方式来完成的。这个考验的是产品、设计、开发人员的功底，协作程度、责任心等各个方面。功能设计方面：是否在协调用户体验和产品目标上找到最佳的平衡点？是否在最合适的场合为用户呈现了他需要的功能和帮助？是否考虑到了用户所以的使用场景？视觉设计方面：画面布局是否美观？颜色、字体是否恰到好处？动效设计是否流畅？用户体验方面：操作流程是否简单易理解？功能的使用是否存在技术门槛？是否考虑到了每个细节上对用户的引导？技术架构实现方面：技术选型是否合理？正常异常分支是否都考虑到位？测试是否全面？性能是否过关？是否考虑到了多平台、多机型的适配？从专业的产品设计和技术视角评判一款产品。每个功能都是完美的操作体验，每个页面都是最美的视觉效果，以最优的代码实现，最低的故障率，最快的响应速度呈现给用户，才是好产品。举个例子，印象笔记这款产品，无论是移动端还是PC端、Mac端，其产品设计实现都非常完美。画面美观、设计独特、交互体验好、运行流畅、就连付费功能展示的时机也是恰到好处，不会让用户厌烦。从产品设计角度来说，印象笔记是款好产品。 (⊙o⊙)…所以如何开发出一款好的产品，作为开发人员，无论是功能交互还是UI设计，还是要修一下的。除了看交互设计书，最重要的就是上手体验了，所以接下来上手了一些小而美、做的精致的APP，看一下别人是怎么设计界面，怎么做功能交互的。一言、MOZIK、留白、落网 这几个算是小而美精致，掘金、慕课网、SegmentFault、人人都是产品经理 这些也是优美。 01~10号 11月份开始，首先开始的是对用户界面的设计，因为设计狮的空缺，只能自己上了。趁着当当搞满减活动，买了几本UI设计跟产品交互的书。这段时间也比较关注产品设计，所以一些设计网站和产品社区也经常逛，比如站酷、我是PM这些，提供了灵感以及开阔眼界和思路。色彩的应用有了点头绪，对于色彩的选择真的很重要： 接下来是接口设计还有维护以前的项目。 包括优化了UI界面以及用户操作，修复隐藏的bug。其中，websocket得到了健壮性的保证。 11~20号 用了四年的笔记本，终于，我重装了系统，如获新生。之前可是打个字，搜狗输入法都卡个很久，更别说打开浏览器，打开编译器，打开虚拟机。其中最主要让我下定决心重装的原因是Photoshop因为内存不够打不开，图都P不了，忍无可忍，终于对它下手了，虽然重装软件配置环境什么的很多。然后，经过一周的资料搜索（工作内容）以及讨论会议。在PPAP群里偶然提起了Flutter之后，我决定花点精力去了解这个东西，之前是知道这个东西的，但是没有深入了解。首先是环境的搭建，刚开始按着教程搭，开发编辑器一个是vscode，另一个是Android Studio。因为刚开始嫌Android Studio太重，所以以为不用装，就出现命令运行不通过。提醒Android Studio未安装，装了之后，又出现其他问题。后面配置好了环境，终于可以跑起来了，60FPS极致丝滑： 很鸡冻有木有(๑&gt;؂&lt;๑） 21~30号 上周的讨论依然没有结果，大方向这些东西没定好（工作内容），接下来继续分析（册子）。发挥想象力，APP项目UI主题色与结构改变之后的界面： 再一次证明了色彩的重要性(๑&gt;؂&lt;๑）。 因为自己计划着手微信小程序项目，PPAP之前是有一个产品雏形的，一直没落实，也没想好底层逻辑，也没进展，后面我就想把这个带起来，就牵了个头，安排任务给他们（虽然技术成长需要时间），算是有了个开始吧，虽然现阶段文档不齐全，技术暂时还对不上。也是为了实践计划，在码云上搭建了项目仓库，开始协作开发。也是由于PPAP年轻人技术不同步,包括前端后端，以及产品逻辑不完善，暂时也没个法子。现在就是搭个项目作为DEMO来作为pratice: 也就差不多这样子啦(๑&gt;؂&lt;๑），12月份也是个需要奋斗的月份，接下来把miniprogram过掉，就可以LU一遍webpack4了，后面就要研究一下Flutter了，期待12月23号的 Google DevFest 2018广州国际嘉年华~]]></content>
      <categories>
        <category>生活与工作</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探和实现websocket心跳重连]]></title>
    <url>%2F2018%2F11%2F21%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[心跳重连缘由websocket 是前后端交互的长连接，前后端也都可能因为一些情况导致连接失效并且相互之间没有反馈提醒。因此为了保证连接的可持续性和稳定性，websocket 心跳重连就应运而生。在使用原生 websocket 的时候，如果设备网络断开，不会触发 websocket 的任何事件函数，前端程序无法得知当前连接已经断开。这个时候如果调用 websocket.send 方法，浏览器就会发现消息发不出去，便会立刻或者一定短时间后（不同浏览器或者浏览器版本可能表现不同）触发 onclose 函数。后端 websocket 服务也可能出现异常，连接断开后前端也并没有收到通知，因此需要前端定时发送心跳消息 ping ，后端收到 ping 类型的消息，立马返回 pong 消息，告知前端连接正常。如果一定时间没收到 pong 消息，就说明连接不正常，前端便会执行重连。为了解决以上两个问题，以前端作为主动方，定时发送 ping 消息，用于检测网络和前后端连接问题。一旦发现异常，前端持续执行重连逻辑，直到重连成功。 如何实现在 websocket 实例化的时候，我们会绑定一些事件：1234567891011121314var ws = new WebSocket(url);ws.onclose = function () &#123; //something&#125;;ws.onerror = function () &#123; //something&#125;; ws.onopen = function () &#123; //something&#125;;ws.onmessage = function (event) &#123; //something&#125; 如果希望 websocket 连接一直保持，我们会在 close 或者 error 上绑定重新连接方法。123456ws.onclose = function () &#123; reconnect();&#125;;ws.onerror = function () &#123; reconnect();&#125;; 这样一般正常情况下失去连接时，触发 onclose 方法，我们就能执行重连了。 那么针对断网的情况的心跳重连，怎么实现呢。简单的实现：123456789101112131415161718192021var heartCheck = &#123; timeout: 60000,//60ms timeoutObj: null, reset: function()&#123; clearTimeout(this.timeoutObj); this.start(); &#125;, start: function()&#123; this.timeoutObj = setTimeout(function()&#123; ws.send("HeartBeat"); &#125;, this.timeout) &#125;&#125;ws.onopen = function () &#123; heartCheck.start();&#125;;ws.onmessage = function (event) &#123; heartCheck.reset();&#125; 如上代码，heartCheck 的 reset 和 start 方法主要用来控制心跳的定时。 什么条件下执行心跳：当 onopen 也就是连接上时，我们便开始 start 计时，如果在定时时间范围内，onmessage获取到了后端的消息，我们就重置倒计时，距离上次从后端获取到消息超过 60 秒之后，执行心跳检测，看是不是断连了，这个检测时间可以自己根据自身情况设定。 判断前端ws断开(断网但不限于断网的情况）：当心跳检测 send 方法执行之后，如果当前 websocket 是断开状态(或者说断网了)，发送超时之后，浏览器的 ws 会自动触发 onclose 方法，重连也执行了（ onclose 方法体绑定了重连事件），如果当前一直是断网状态，重连会 2 秒（时间是自己代码设置的）执行一次直到网络正常后连接成功。如此一来，我们判断前端主动断开ws的心跳检测就实现了。为什么说是前端主动断开，因为当前这种情况主要是通过前端ws的事件来判断的，后面说后端主动断开的情况。 在测试 websocket 超时时间，又发现了一些新的问题 在 chrome 中，如果心跳检测 也就是 websocket 实例执行 send 之后，15 秒内没发送到另一接收端，onclose 便会执行。那么超时时间是 15 秒。 Firefox 在断网7秒之后，直接执行 onclose。说明在 Firefox 中不需要心跳检测便能自动 onclose。 同一代码，reconnect 方法在 chrome 执行了一次，Firefox 执行了两次。当然我们在几处地方（代码逻辑处和 websocket 事件处）绑定了 reconnect()，所以保险起见，我们还是给 reconnect() 方法加上一个锁，保证只执行一次 目前来看不同的浏览器，有不同的机制，无论浏览器 websocket 自身会不会在断网情况下执行 onclose，加上心跳重连后，已经能保证 onclose 的正常触发。 判断后端断开：如果后端因为一些情况断开了 ws，是可控情况下的话，会下发一个断连的消息通知，之后才会断开，我们便会重连。如果因为一些异常断开了连接，我们是不会感应到的，所以如果我们发送了心跳一定时间之后，后端既没有返回心跳响应消息，前端又没有收到任何其他消息的话，我们就能断定后端主动断开了。一点特别重要的发送心跳到后端，后端收到消息之后必须返回消息，否则超过 60 秒之后会判定后端主动断开了。再改造下代码: 123456789101112131415161718192021222324252627282930313233var heartCheck = &#123; timeout: 60000,//60ms timeoutObj: null, serverTimeoutObj: null, reset: function()&#123; clearTimeout(this.timeoutObj); clearTimeout(this.serverTimeoutObj); this.start(); &#125;, start: function()&#123; var self = this; this.timeoutObj = setTimeout(function()&#123; ws.send("HeartBeat"); self.serverTimeoutObj = setTimeout(function()&#123; ws.close();//如果onclose会执行reconnect，执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次 &#125;, self.timeout) &#125;, this.timeout) &#125;,&#125;ws.onopen = function () &#123; heartCheck.start();&#125;;ws.onmessage = function (event) &#123; heartCheck.reset();&#125;ws.onclose = function () &#123; reconnect();&#125;;ws.onerror = function () &#123; reconnect();&#125;; PS： 因为目前这种方式会一直重连如果没连接上或者断连的话，如果有两个设备同时登陆并且会踢另一端下线，一定要发送一个踢下线的消息类型，这边接收到这种类型的消息，逻辑判断后就不再执行 reconnect，否则会出现一只相互挤下线的死循环。 此篇博文转自@子暮大诗人，代码已封装为库websocket-heartbeat-js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10月份 / Summary]]></title>
    <url>%2F2018%2F11%2F01%2Fsummary_201810%2F</url>
    <content type="text"><![CDATA[#summary_201810_01, #summary_201810_02, #summary_201810_03, #summary_201810_04, #summary_201810_05, #summary_201810_06{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #summary_201810_01:hover, #summary_201810_02:hover, #summary_201810_03:hover, #summary_201810_04:hover, #summary_201810_05:hover, #summary_201810_06:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 未央十月，清风微似梦 十月份于我，是一个慵懒的月份，也是个探索的月份，没有coding的紧迫感，也没有八九月份的热情。 01~07号 在经历过对未知领域与技术的了解与实践后，九月末搭建了博客，接着就开启了一个星期的国庆假期，在经过了佛性的几天后，抓着假期的尾巴，去了长隆水上乐园，太阳很猛，水温很凉，全程玩下来整整一个下午，单论玩真的很值，很刺激，过后泡个温泉浴，身心舒畅，回来站上体重秤一秤发现轻了两斤，血亏！(因为博主9月中旬制定了增重计划)，建议需要减肥的同学可以去玩一哈…… 急驰竞赛 08~14号 十一假期回来，继续捣鼓博客网站。在观摩了许多大佬的网站之后，开始了对自己博客的美化之路。除此之外，拜读了许多大佬的文章之后，感叹于他们对技术的执着，其中很大部分都还是高中生，或者大多数是ACG爱好者，大概是“用爱发电”吧。这个星期主要是捣鼓Hexo、收集资源以及观摩大佬博客，达到自惭形愧以自我鞭笞。 周末回去了大学城，在中心湖周围逛了一下，端庄地坐在草地上，喝着益禾堂烤奶，看着岛外的各个家庭一家几口的在这边野餐露营，放着风筝，孩子打闹嬉戏，也是一片和谐有爱… 中心湖草地 15~21号 本周继续研究Hexo，开始着手发表文章，完成“关于”页面的编写，也是在本周，在收集资源的过程中，从吐槽站的群里发现了个大佬，后面发现了clicli.us，技术宅是真的改变世界，我不由得去思考二次元文化对他们的影响（或许真的有丶东西？喜欢二次元的不一定是大佬，但大佬很多都是二次元爱好者？）。于是，一是因为自己喜欢动漫，虽然没有每部番都追，但是追的番都会追完，二是为了给博客找素材，我也开始进入ACG的圈子一探究竟…… 周六部门团建，帽峰山之旅。帽峰山之貌，山坡陡峭，沟谷深幽，地形多变，群山漭漭，鸟语花香，幽静怡人。遂登顶开黑，组队互殴，甚是快哉。 周日在科学中心巨幕影院看了《无双》，真真假假，真是”钞”级大片。 流水账的视觉…… 山湖 登顶 开黑 22~31号 本周刚好是博主增重计划的第一个周期，目标一个月增重十斤，你猜怎么着？当然是……完成目标！哇，三分锻炼七分吃，这七分有丶费钱。啊啊啊啊啊，本周主要是对下一个项目进行需求分析与界面设计，还有就是对上个APP项目进行优化和debug。 以前对于移动端设计简直小白，很多都还是web的思维模式，也是因为对移动端设计页面的不了解，后面见多了，会类比，什么样的界面更加美观，什么样的操作有更好的用户体验，这些东西还需要慢慢学习……当然，现在对于界面样式调试的熟练度比半年前进步了，可以也愿意去尝试新属性带来的效果……写代码还是得靠经验啊，踩的坑多了，研究过了对知识点的掌握才会更深刻。代码可以隔一段时间去review一下，你会发现以前写的代码思维跟你现在写代码的思维的区别。对以前糟糕的代码进行重构，减少代码间的耦合性，预留扩展功能，维护起来就会减少很多不必要的麻烦！ 展望 话说写文章真的很费劲，emmmm……要花很多心思……但，十一月，注定是奋斗的月份,我要打鸡血了！！！！Boooooommmmmm~冲鸭！]]></content>
      <categories>
        <category>生活与工作</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序 / INTRO]]></title>
    <url>%2F2018%2F10%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[生命的幻影穿过狭长的岁月向东向西消失在暮色里—— 改编自《生命幻想曲》顾城]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗 / Poem]]></title>
    <url>%2F2018%2F10%2F17%2Fpoem_1%2F</url>
    <content type="text"><![CDATA[所遇即所爱幸之所在]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
</search>
